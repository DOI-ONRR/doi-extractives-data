[
  {
    "description": "A data model for storing named datasets.",
    "tags": [
      {
        "title": "example",
        "description": "var model = new eiti.data.Model();"
      },
      {
        "title": "class",
        "description": null,
        "type": null,
        "name": null
      },
      {
        "title": "alias",
        "description": null,
        "name": "eiti.data.Model"
      },
      {
        "title": "param",
        "description": "optional datasets to initialize",
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Object"
            },
            {
              "type": "NameExpression",
              "name": "d3.map"
            }
          ]
        },
        "name": "data"
      },
      {
        "title": "name",
        "name": "Model"
      },
      {
        "title": "kind",
        "kind": "class"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 191,
          "column": 4
        },
        "end": {
          "line": 194,
          "column": 6
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  }"
    },
    "examples": [
      "<span class=\"hljs-keyword\">var</span> model = <span class=\"hljs-keyword\">new</span> eiti.data.Model();"
    ],
    "params": [
      {
        "title": "param",
        "description": "optional datasets to initialize",
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Object"
            },
            {
              "type": "NameExpression",
              "name": "d3.map"
            }
          ]
        },
        "name": "data"
      }
    ],
    "name": "Model",
    "kind": "class",
    "members": {
      "instance": [
        {
          "description": "Load data from a URL into a named dataset.",
          "tags": [
            {
              "title": "example",
              "description": "model.load('states', 'path/to/states.json', function(error, topology) {\n});"
            },
            {
              "title": "param",
              "description": "the unique dataset name",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "name"
            },
            {
              "title": "param",
              "description": "the URL to load",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "url"
            },
            {
              "title": "param",
              "description": "the callback function",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "Function"
                }
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "load"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "Model"
            },
            {
              "title": "instance"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 233,
                "column": 4
              },
              "end": {
                "line": 244,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.js",
            "code": "{\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  }"
          },
          "examples": [
            "model.load(<span class=\"hljs-string\">'states'</span>, <span class=\"hljs-string\">'path/to/states.json'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(error, topology)</span> </span>{\n});"
          ],
          "params": [
            {
              "title": "param",
              "description": "the unique dataset name",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "name"
            },
            {
              "title": "param",
              "description": "the URL to load",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "url"
            },
            {
              "title": "param",
              "description": "the callback function",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "Function"
                }
              },
              "name": "callback"
            }
          ],
          "name": "load",
          "kind": "function",
          "memberof": "Model",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Model",
            "load"
          ]
        },
        {
          "description": "",
          "tags": [
            {
              "title": "param",
              "description": "the dataset name",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "name"
            },
            {
              "title": "returns",
              "description": "`true` if the named dataset exists, `false` if not",
              "type": {
                "type": "NameExpression",
                "name": "Boolean"
              }
            },
            {
              "title": "name",
              "name": "get"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "Model"
            },
            {
              "title": "instance"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 208,
                "column": 4
              },
              "end": {
                "line": 210,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.js",
            "code": "{\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  }"
          },
          "params": [
            {
              "title": "param",
              "description": "the dataset name",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "name"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "`true` if the named dataset exists, `false` if not",
              "type": {
                "type": "NameExpression",
                "name": "Boolean"
              }
            }
          ],
          "name": "get",
          "kind": "function",
          "memberof": "Model",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Model",
            "get"
          ]
        },
        {
          "description": "",
          "tags": [
            {
              "title": "param",
              "description": "the dataset name",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "name"
            },
            {
              "title": "returns",
              "description": "`true` if the named dataset exists, `false` if not",
              "type": {
                "type": "NameExpression",
                "name": "Boolean"
              }
            },
            {
              "title": "name",
              "name": "has"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "Model"
            },
            {
              "title": "instance"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 200,
                "column": 4
              },
              "end": {
                "line": 202,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.js",
            "code": "{\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  }"
          },
          "params": [
            {
              "title": "param",
              "description": "the dataset name",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "name"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "`true` if the named dataset exists, `false` if not",
              "type": {
                "type": "NameExpression",
                "name": "Boolean"
              }
            }
          ],
          "name": "has",
          "kind": "function",
          "memberof": "Model",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Model",
            "has"
          ]
        },
        {
          "description": "Store a dataset with a unique key",
          "tags": [
            {
              "title": "param",
              "description": "the dataset name",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "name"
            },
            {
              "title": "param",
              "description": "the data to store",
              "type": {
                "type": "AllLiteral"
              },
              "name": "data"
            },
            {
              "title": "returns",
              "description": "returns the data as set",
              "type": {
                "type": "AllLiteral"
              }
            },
            {
              "title": "name",
              "name": "set"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "Model"
            },
            {
              "title": "instance"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 218,
                "column": 4
              },
              "end": {
                "line": 220,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.js",
            "code": "{\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  }"
          },
          "params": [
            {
              "title": "param",
              "description": "the dataset name",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "name"
            },
            {
              "title": "param",
              "description": "the data to store",
              "type": {
                "type": "AllLiteral"
              },
              "name": "data"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "returns the data as set",
              "type": {
                "type": "AllLiteral"
              }
            }
          ],
          "name": "set",
          "kind": "function",
          "memberof": "Model",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Model",
            "set"
          ]
        },
        {
          "description": "Create a nested index using {@link eiti.data.nest} from a\nnamed dataset and alias it to a new name.",
          "tags": [
            {
              "title": "example",
              "description": "model.set('foo', [\n  {x: 'bar', y: 'baz'},\n  {x: 'qux', y: 'quux'}\n]);\nvar index = model.createIndex('foo', 'bar', ['x', 'y']);\nassert.deepEqual(index, {\n  bar: {\n    baz: [\n      {x: 'bar', y: 'baz'}\n    ],\n  },\n  qux: {\n    quux: [\n      {x: 'qux', y: 'quux'}\n    ]\n  }\n});"
            },
            {
              "title": "param",
              "description": "the source dataset name",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "src"
            },
            {
              "title": "param",
              "description": "the destination dataset name",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "dest"
            },
            {
              "title": "param",
              "description": "the keys to nest",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "UnionType",
                    "elements": [
                      {
                        "type": "NameExpression",
                        "name": "String"
                      },
                      {
                        "type": "NameExpression",
                        "name": "Function"
                      }
                    ]
                  }
                ]
              },
              "name": "keys"
            },
            {
              "title": "param",
              "description": "the optional rollup function",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "Function"
                }
              },
              "name": "rollup"
            },
            {
              "title": "name",
              "name": "createIndex"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "Model"
            },
            {
              "title": "instance"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 274,
                "column": 4
              },
              "end": {
                "line": 279,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.js",
            "code": "{\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  }"
          },
          "examples": [
            "model.set(<span class=\"hljs-string\">'foo'</span>, [\n  {x: <span class=\"hljs-string\">'bar'</span>, y: <span class=\"hljs-string\">'baz'</span>},\n  {x: <span class=\"hljs-string\">'qux'</span>, y: <span class=\"hljs-string\">'quux'</span>}\n]);\n<span class=\"hljs-keyword\">var</span> index = model.createIndex(<span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-string\">'bar'</span>, [<span class=\"hljs-string\">'x'</span>, <span class=\"hljs-string\">'y'</span>]);\nassert.deepEqual(index, {\n  bar: {\n    baz: [\n      {x: <span class=\"hljs-string\">'bar'</span>, y: <span class=\"hljs-string\">'baz'</span>}\n    ],\n  },\n  qux: {\n    quux: [\n      {x: <span class=\"hljs-string\">'qux'</span>, y: <span class=\"hljs-string\">'quux'</span>}\n    ]\n  }\n});"
          ],
          "params": [
            {
              "title": "param",
              "description": "the source dataset name",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "src"
            },
            {
              "title": "param",
              "description": "the destination dataset name",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "dest"
            },
            {
              "title": "param",
              "description": "the keys to nest",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "UnionType",
                    "elements": [
                      {
                        "type": "NameExpression",
                        "name": "String"
                      },
                      {
                        "type": "NameExpression",
                        "name": "Function"
                      }
                    ]
                  }
                ]
              },
              "name": "keys"
            },
            {
              "title": "param",
              "description": "the optional rollup function",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "Function"
                }
              },
              "name": "rollup"
            }
          ],
          "name": "createIndex",
          "kind": "function",
          "memberof": "Model",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Model",
            "createIndex"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "Model"
    ]
  },
  {
    "description": "An area chart generator for d3.",
    "tags": [
      {
        "title": "example",
        "description": "var area = eiti.charts.area()\n  .x(function(d) { return d.year; })\n  .y(function(d) { return d.category; })\n  .value(function(d) { return d.value; });\n\nd3.select('svg')\n  .call(area, [\n     {year: 2000, category: 'x', value: 10},\n     {year: 2001, category: 'x', value: 12},\n     // ...\n     {year: 2010, category: 'y', value: 8}\n  ]);"
      },
      {
        "title": "name",
        "description": null,
        "name": "eiti.charts.area"
      },
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "areaChart"
        }
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.charts"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 28,
          "column": 2
        },
        "end": {
          "line": 353,
          "column": 4
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.charts.js",
      "code": "{\n\n  var eiti = exports.eiti;\n\n  var getter = eiti.data.getter;\n\n  eiti.charts = {};\n\n  /**\n   * An area chart generator for d3.\n   *\n   * @example\n   * var area = eiti.charts.area()\n   *   .x(function(d) { return d.year; })\n   *   .y(function(d) { return d.category; })\n   *   .value(function(d) { return d.value; });\n   *\n   * d3.select('svg')\n   *   .call(area, [\n   *      {year: 2000, category: 'x', value: 10},\n   *      {year: 2001, category: 'x', value: 12},\n   *      // ...\n   *      {year: 2010, category: 'y', value: 8}\n   *   ]);\n   * @name eiti.charts.area\n   * @returns {areaChart}\n   */\n  eiti.charts.area = function() {\n    var dx = getter('Year');\n    var dy = getter('Commodity');\n    var value = getter('Revenue');\n    var stacked = false;\n    var log = false;\n\n    var width = 960;\n    var height = 100;\n\n    var margin = {\n      top: 10,\n      bottom: 25,\n      left: 50,\n      right: 20\n    };\n\n    var axisSpacing = 5;\n\n    var fill = d3.scale.category10();\n    var interpolate = 'cardinal';\n\n    var voronoi = false;\n\n    /**\n     * Renders a chart in a given d3 selection. Use {@link\n     * eiti.charts.area} to create one.\n     *\n     * @namespace areaChart\n     * @param {d3.selection} svg  a d3 `<svg>` element selection\n     * @param {Array=} data optional data\n     */\n    var areaChart = function(svg, data) {\n      if (data) {\n        svg.datum(data);\n      } else {\n        data = svg.datum() || [];\n      }\n      svg.attr('viewBox', [0, 0, width, height].join(' '));\n\n      var index = d3.nest()\n        .key(dy)\n        .key(dx)\n        .rollup(function(d) {\n          return d3.sum(d, value);\n        })\n        .map(data);\n\n      var xs = d3.extent(data, dx).map(Number);\n      var ys = d3.keys(index);\n      var xd = d3.range(xs[0], xs[1] + 1);\n      var layers = ys.map(function(y) {\n        return xd.map(function(x) {\n          var z = index[y][x] || 0;\n          if (stacked && z < 0) z = 0;\n          return {\n            x: x,\n            y: z,\n            key: y\n          };\n        });\n      });\n\n      layers.forEach(function(d) {\n        d.key = d[0].key;\n        d.sum = d3.sum(d, getter('y'));\n      });\n\n      layers.sort(function(a, b) {\n        return d3.descending(a.sum, b.sum);\n      });\n\n      var aggr = stacked ? d3.sum : d3.max;\n      var yd = d3.extent(xd, function(x, i) {\n        return aggr(layers, function(d) {\n          return d[i].y;\n        });\n      });\n\n      var y0 = height - margin.bottom;\n      var y1 = margin.top;\n\n      var y = log\n        ? d3.scale.log()\n          .domain([1, yd[1]])\n          .range([y0, y1])\n          .clamp(true)\n        : d3.scale.linear()\n          .domain([0, yd[1]])\n          .range([y0, y1]);\n      y.nice();\n\n      var x = d3.scale.linear()\n        .domain(d3.extent(data, dx))\n        .range([margin.left, width - margin.right]);\n\n      var yAxis = d3.svg.axis()\n        .orient('left')\n        .scale(y);\n\n      var si = d3.format('s');\n      var suffix = {K: 'k', M: 'm', G: 'b'};\n      var ticks = 3;\n      var yFormat = function(n, i) {\n        var p = (i === 0 || i === ticks) ? '$' : '';\n        return p + si(n).replace(/[KMG]$/, function(s) {\n          return suffix[s] || s;\n        });\n      };\n\n      if (log) {\n        ticks -= 1;\n        yAxis.ticks(ticks, yFormat);\n      } else {\n        yAxis.ticks(ticks)\n          .tickFormat(yFormat);\n      }\n\n      svg.append('g')\n        .attr('class', 'axis y')\n        .attr('transform', 'translate(' + [margin.left - axisSpacing, 0] + ')')\n        .call(yAxis);\n\n      svg.append('g')\n        .attr('class', 'axis x')\n        .attr('transform', 'translate(' + [0, height - margin.bottom + axisSpacing] + ')')\n        .call(d3.svg.axis()\n          .orient('bottom')\n          .scale(x)\n          .tickFormat(d3.format('d')));\n\n      var stack = d3.layout.stack();\n\n      var g = svg.selectAll('g.layer')\n        .data(stack(layers))\n        .enter()\n        .append('g')\n          .attr('class', 'layer')\n          .append('a');\n\n      var area = d3.svg.area()\n        .interpolate(interpolate)\n        .x(function(d) { return x(d.x); });\n\n      if (stacked) {\n        area\n          .y0(function(d) { return y(d.y0); })\n          .y1(function(d) { return y(d.y + d.y0); });\n      } else {\n        area\n          .y0(y(0))\n          .y1(function(d) { return y(d.y); });\n      }\n\n      var paths = g.append('path')\n        .attr('fill', function(d) {\n          return fill(d.key);\n        })\n        .attr('d', area);\n\n      if (voronoi) {\n        var points = [];\n        paths.each(function(d) {\n          d.forEach(function(v) {\n            points.push({\n              data: d,\n              value: v,\n              x: x(v.x),\n              y: y(v.y)\n            });\n          });\n        });\n\n        var vor = eiti.charts.voronoi()\n          .points(points)\n          .clipExtent([\n            [margin.left - axisSpacing, margin.top],\n            [width - margin.right + axisSpacing, height - margin.bottom + axisSpacing]\n          ]);\n\n        var regions = svg.append('g')\n          .attr('class', 'voronoi')\n          .call(vor)\n          .selectAll('*')\n            // NB: you have to do this to revert the data \"back\"\n            // to its pre-voronoi() state\n            .datum(function(d) {\n              return d.point.value;\n            });\n      }\n    };\n\n    /**\n     * Get or set the chart's margin in pixels.\n     *\n     * @example\n     * var margin = areaChart.margin();\n     * areaChart.margin({top: 0, right: 20, bottom: 30, left: 10});\n     * areaChart.margin([0, 100]); // NB: [y, x]\n     * areaChart.margin(20); // 20 on all sides\n     *\n     * @param {*=} margin set the margin as returned by {@link eiti.ui.margin}.\n     */\n    areaChart.margin = function(_) {\n      if (!arguments.length) return margin;\n      margin = eiti.ui.margin(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's horizontal value accessor.\n     *\n     * @example\n     * var x = areaChart.x();\n     * areaChart.x(function(d) { return d.Year; });\n     * areaChart.x('Year'); // same as above\n     *\n     * @param {String|Function=} x set the horizontal value accessor\n     */\n    areaChart.x = function(_) {\n      if (!arguments.length) return dx;\n      dx = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's *layer group* accessor.\n     *\n     * @example\n     * var y = areaChart.y();\n     * areaChart.y(function(d) { return d.Commodity; });\n     * areaChart.y('Commodity'); // same as above\n     *\n     * @param {String|Function=} y set the layer group accessor\n     */\n    areaChart.y = function(_) {\n      if (!arguments.length) return dy;\n      dy = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's vertical (numeric) value accessor.\n     *\n     * @example\n     * var value = areaChart.value();\n     * areaChart.value(function(d) { return d.Revenue; });\n     * areaChart.value('Revenue'); // same as above\n     *\n     * @param {String|Function=} v set the vertical value accessor\n     */\n    areaChart.value = function(_) {\n      if (!arguments.length) return value;\n      value = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle stacking layout. Area charts are not stacked by\n     * default.\n     *\n     * @example\n     * var stacked = areaChart.stacked();\n     * areaChart.stacked(true); // tell it to stack\n     *\n     * @param {Boolean=} stacked if `true`, enabled stacking layout\n     */\n    areaChart.stacked = function(_) {\n      if (!arguments.length) return stacked;\n      stacked = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Toggle logarithmic y-axis scaling.\n     *\n     * @example\n     * var log = areaChart.log();\n     * areaChart.log(true); // use logarithmic scaling\n     *\n     * @param {Boolean=} log if `true`, enabled logarithmic scaling\n     */\n    areaChart.log = function(_) {\n      if (!arguments.length) return log;\n      log = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Get or set the layer fill accessor.\n     *\n     * @example\n     * var fill = areaChart.fill();\n     * areaChart.fill(d3.scale.category20());\n     * areaChart.fill(function(d, i) {\n     *   return i % 2 ? 'yellow' : 'orange';\n     * });\n     * areaChart.fill('red');\n     *\n     * @param {*=} fill set the fill accessor\n     */\n    areaChart.fill = function(_) {\n      if (!arguments.length) return fill;\n      fill = d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle creation of Voronoi regions for interactivity.\n     *\n     * @param {Boolean=} voronoi if `true`, voronoi regions will be created\n     */\n    areaChart.voronoi = function(_) {\n      if (!arguments.length) return voronoi;\n      voronoi = _;\n      return areaChart;\n    };\n\n    return areaChart;\n  };\n\n  eiti.charts.voronoi = function() {\n    var points = [];\n    var clipExtent = null;\n\n    var chart = function(svg) {\n      var voronoi = d3.geom.voronoi()\n        .x(function(d) { return d.x; })\n        .y(function(d) { return d.y; })\n        .clipExtent(clipExtent);\n\n      var region = svg.selectAll('g.region')\n        .data(voronoi(points))\n        .enter()\n        .append('g')\n          .attr('class', 'region')\n          .append('a');\n\n      region.append('path')\n        .attr('fill', 'transparent')\n        .attr('d', function poly(v) {\n          return 'M' + v.join('L') + 'Z';\n        });\n\n      region.append('circle')\n        .attr('class', 'point')\n        .attr('transform', function(d) {\n          var p = [d.point.x, d.point.y].map(Math.round);\n          return 'translate(' + p + ')';\n        });\n    };\n\n    chart.points = function(_) {\n      if (!arguments.length) return points;\n      points = _;\n      return chart;\n    };\n\n    chart.clipExtent = function(_) {\n      if (!arguments.length) return clipExtent;\n      clipExtent = _;\n      return chart;\n    };\n\n    return chart;\n  };\n\n}"
    },
    "examples": [
      "<span class=\"hljs-keyword\">var</span> area = eiti.charts.area()\n  .x(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(d)</span> </span>{ <span class=\"hljs-keyword\">return</span> d.year; })\n  .y(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(d)</span> </span>{ <span class=\"hljs-keyword\">return</span> d.category; })\n  .value(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(d)</span> </span>{ <span class=\"hljs-keyword\">return</span> d.value; });\n\nd3.select(<span class=\"hljs-string\">'svg'</span>)\n  .call(area, [\n     {year: <span class=\"hljs-number\">2000</span>, category: <span class=\"hljs-string\">'x'</span>, value: <span class=\"hljs-number\">10</span>},\n     {year: <span class=\"hljs-number\">2001</span>, category: <span class=\"hljs-string\">'x'</span>, value: <span class=\"hljs-number\">12</span>},\n     <span class=\"hljs-comment\">// ...</span>\n     {year: <span class=\"hljs-number\">2010</span>, category: <span class=\"hljs-string\">'y'</span>, value: <span class=\"hljs-number\">8</span>}\n  ]);"
    ],
    "name": "eiti.charts.area",
    "returns": [
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "areaChart"
        }
      }
    ],
    "kind": "function",
    "memberof": "eiti.charts",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.charts.area"
    ]
  },
  {
    "description": "Renders a chart in a given d3 selection. Use {@link\neiti.charts.area} to create one.",
    "tags": [
      {
        "title": "namespace",
        "description": null,
        "type": null,
        "name": "areaChart"
      },
      {
        "title": "param",
        "description": "a d3 `<svg>` element selection",
        "type": {
          "type": "NameExpression",
          "name": "d3.selection"
        },
        "name": "svg"
      },
      {
        "title": "param",
        "description": "optional data",
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          }
        },
        "name": "data"
      },
      {
        "title": "name",
        "name": "areaChart"
      },
      {
        "title": "kind",
        "kind": "namespace"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 60,
          "column": 4
        },
        "end": {
          "line": 218,
          "column": 6
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.charts.js",
      "code": "{\n    var dx = getter('Year');\n    var dy = getter('Commodity');\n    var value = getter('Revenue');\n    var stacked = false;\n    var log = false;\n\n    var width = 960;\n    var height = 100;\n\n    var margin = {\n      top: 10,\n      bottom: 25,\n      left: 50,\n      right: 20\n    };\n\n    var axisSpacing = 5;\n\n    var fill = d3.scale.category10();\n    var interpolate = 'cardinal';\n\n    var voronoi = false;\n\n    /**\n     * Renders a chart in a given d3 selection. Use {@link\n     * eiti.charts.area} to create one.\n     *\n     * @namespace areaChart\n     * @param {d3.selection} svg  a d3 `<svg>` element selection\n     * @param {Array=} data optional data\n     */\n    var areaChart = function(svg, data) {\n      if (data) {\n        svg.datum(data);\n      } else {\n        data = svg.datum() || [];\n      }\n      svg.attr('viewBox', [0, 0, width, height].join(' '));\n\n      var index = d3.nest()\n        .key(dy)\n        .key(dx)\n        .rollup(function(d) {\n          return d3.sum(d, value);\n        })\n        .map(data);\n\n      var xs = d3.extent(data, dx).map(Number);\n      var ys = d3.keys(index);\n      var xd = d3.range(xs[0], xs[1] + 1);\n      var layers = ys.map(function(y) {\n        return xd.map(function(x) {\n          var z = index[y][x] || 0;\n          if (stacked && z < 0) z = 0;\n          return {\n            x: x,\n            y: z,\n            key: y\n          };\n        });\n      });\n\n      layers.forEach(function(d) {\n        d.key = d[0].key;\n        d.sum = d3.sum(d, getter('y'));\n      });\n\n      layers.sort(function(a, b) {\n        return d3.descending(a.sum, b.sum);\n      });\n\n      var aggr = stacked ? d3.sum : d3.max;\n      var yd = d3.extent(xd, function(x, i) {\n        return aggr(layers, function(d) {\n          return d[i].y;\n        });\n      });\n\n      var y0 = height - margin.bottom;\n      var y1 = margin.top;\n\n      var y = log\n        ? d3.scale.log()\n          .domain([1, yd[1]])\n          .range([y0, y1])\n          .clamp(true)\n        : d3.scale.linear()\n          .domain([0, yd[1]])\n          .range([y0, y1]);\n      y.nice();\n\n      var x = d3.scale.linear()\n        .domain(d3.extent(data, dx))\n        .range([margin.left, width - margin.right]);\n\n      var yAxis = d3.svg.axis()\n        .orient('left')\n        .scale(y);\n\n      var si = d3.format('s');\n      var suffix = {K: 'k', M: 'm', G: 'b'};\n      var ticks = 3;\n      var yFormat = function(n, i) {\n        var p = (i === 0 || i === ticks) ? '$' : '';\n        return p + si(n).replace(/[KMG]$/, function(s) {\n          return suffix[s] || s;\n        });\n      };\n\n      if (log) {\n        ticks -= 1;\n        yAxis.ticks(ticks, yFormat);\n      } else {\n        yAxis.ticks(ticks)\n          .tickFormat(yFormat);\n      }\n\n      svg.append('g')\n        .attr('class', 'axis y')\n        .attr('transform', 'translate(' + [margin.left - axisSpacing, 0] + ')')\n        .call(yAxis);\n\n      svg.append('g')\n        .attr('class', 'axis x')\n        .attr('transform', 'translate(' + [0, height - margin.bottom + axisSpacing] + ')')\n        .call(d3.svg.axis()\n          .orient('bottom')\n          .scale(x)\n          .tickFormat(d3.format('d')));\n\n      var stack = d3.layout.stack();\n\n      var g = svg.selectAll('g.layer')\n        .data(stack(layers))\n        .enter()\n        .append('g')\n          .attr('class', 'layer')\n          .append('a');\n\n      var area = d3.svg.area()\n        .interpolate(interpolate)\n        .x(function(d) { return x(d.x); });\n\n      if (stacked) {\n        area\n          .y0(function(d) { return y(d.y0); })\n          .y1(function(d) { return y(d.y + d.y0); });\n      } else {\n        area\n          .y0(y(0))\n          .y1(function(d) { return y(d.y); });\n      }\n\n      var paths = g.append('path')\n        .attr('fill', function(d) {\n          return fill(d.key);\n        })\n        .attr('d', area);\n\n      if (voronoi) {\n        var points = [];\n        paths.each(function(d) {\n          d.forEach(function(v) {\n            points.push({\n              data: d,\n              value: v,\n              x: x(v.x),\n              y: y(v.y)\n            });\n          });\n        });\n\n        var vor = eiti.charts.voronoi()\n          .points(points)\n          .clipExtent([\n            [margin.left - axisSpacing, margin.top],\n            [width - margin.right + axisSpacing, height - margin.bottom + axisSpacing]\n          ]);\n\n        var regions = svg.append('g')\n          .attr('class', 'voronoi')\n          .call(vor)\n          .selectAll('*')\n            // NB: you have to do this to revert the data \"back\"\n            // to its pre-voronoi() state\n            .datum(function(d) {\n              return d.point.value;\n            });\n      }\n    };\n\n    /**\n     * Get or set the chart's margin in pixels.\n     *\n     * @example\n     * var margin = areaChart.margin();\n     * areaChart.margin({top: 0, right: 20, bottom: 30, left: 10});\n     * areaChart.margin([0, 100]); // NB: [y, x]\n     * areaChart.margin(20); // 20 on all sides\n     *\n     * @param {*=} margin set the margin as returned by {@link eiti.ui.margin}.\n     */\n    areaChart.margin = function(_) {\n      if (!arguments.length) return margin;\n      margin = eiti.ui.margin(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's horizontal value accessor.\n     *\n     * @example\n     * var x = areaChart.x();\n     * areaChart.x(function(d) { return d.Year; });\n     * areaChart.x('Year'); // same as above\n     *\n     * @param {String|Function=} x set the horizontal value accessor\n     */\n    areaChart.x = function(_) {\n      if (!arguments.length) return dx;\n      dx = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's *layer group* accessor.\n     *\n     * @example\n     * var y = areaChart.y();\n     * areaChart.y(function(d) { return d.Commodity; });\n     * areaChart.y('Commodity'); // same as above\n     *\n     * @param {String|Function=} y set the layer group accessor\n     */\n    areaChart.y = function(_) {\n      if (!arguments.length) return dy;\n      dy = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's vertical (numeric) value accessor.\n     *\n     * @example\n     * var value = areaChart.value();\n     * areaChart.value(function(d) { return d.Revenue; });\n     * areaChart.value('Revenue'); // same as above\n     *\n     * @param {String|Function=} v set the vertical value accessor\n     */\n    areaChart.value = function(_) {\n      if (!arguments.length) return value;\n      value = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle stacking layout. Area charts are not stacked by\n     * default.\n     *\n     * @example\n     * var stacked = areaChart.stacked();\n     * areaChart.stacked(true); // tell it to stack\n     *\n     * @param {Boolean=} stacked if `true`, enabled stacking layout\n     */\n    areaChart.stacked = function(_) {\n      if (!arguments.length) return stacked;\n      stacked = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Toggle logarithmic y-axis scaling.\n     *\n     * @example\n     * var log = areaChart.log();\n     * areaChart.log(true); // use logarithmic scaling\n     *\n     * @param {Boolean=} log if `true`, enabled logarithmic scaling\n     */\n    areaChart.log = function(_) {\n      if (!arguments.length) return log;\n      log = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Get or set the layer fill accessor.\n     *\n     * @example\n     * var fill = areaChart.fill();\n     * areaChart.fill(d3.scale.category20());\n     * areaChart.fill(function(d, i) {\n     *   return i % 2 ? 'yellow' : 'orange';\n     * });\n     * areaChart.fill('red');\n     *\n     * @param {*=} fill set the fill accessor\n     */\n    areaChart.fill = function(_) {\n      if (!arguments.length) return fill;\n      fill = d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle creation of Voronoi regions for interactivity.\n     *\n     * @param {Boolean=} voronoi if `true`, voronoi regions will be created\n     */\n    areaChart.voronoi = function(_) {\n      if (!arguments.length) return voronoi;\n      voronoi = _;\n      return areaChart;\n    };\n\n    return areaChart;\n  }"
    },
    "params": [
      {
        "title": "param",
        "description": "a d3 `<svg>` element selection",
        "type": {
          "type": "NameExpression",
          "name": "d3.selection"
        },
        "name": "svg"
      },
      {
        "title": "param",
        "description": "optional data",
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          }
        },
        "name": "data"
      }
    ],
    "name": "areaChart",
    "kind": "namespace",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Get or set the chart's *layer group* accessor.",
          "tags": [
            {
              "title": "example",
              "description": "var y = areaChart.y();\nareaChart.y(function(d) { return d.Commodity; });\nareaChart.y('Commodity'); // same as above"
            },
            {
              "title": "param",
              "description": "set the layer group accessor",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "UnionType",
                  "elements": [
                    {
                      "type": "NameExpression",
                      "name": "String"
                    },
                    {
                      "type": "NameExpression",
                      "name": "Function"
                    }
                  ]
                }
              },
              "name": "y"
            },
            {
              "title": "name",
              "name": "y"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "areaChart"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 265,
                "column": 4
              },
              "end": {
                "line": 271,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.charts.js",
            "code": "{\n    var dx = getter('Year');\n    var dy = getter('Commodity');\n    var value = getter('Revenue');\n    var stacked = false;\n    var log = false;\n\n    var width = 960;\n    var height = 100;\n\n    var margin = {\n      top: 10,\n      bottom: 25,\n      left: 50,\n      right: 20\n    };\n\n    var axisSpacing = 5;\n\n    var fill = d3.scale.category10();\n    var interpolate = 'cardinal';\n\n    var voronoi = false;\n\n    /**\n     * Renders a chart in a given d3 selection. Use {@link\n     * eiti.charts.area} to create one.\n     *\n     * @namespace areaChart\n     * @param {d3.selection} svg  a d3 `<svg>` element selection\n     * @param {Array=} data optional data\n     */\n    var areaChart = function(svg, data) {\n      if (data) {\n        svg.datum(data);\n      } else {\n        data = svg.datum() || [];\n      }\n      svg.attr('viewBox', [0, 0, width, height].join(' '));\n\n      var index = d3.nest()\n        .key(dy)\n        .key(dx)\n        .rollup(function(d) {\n          return d3.sum(d, value);\n        })\n        .map(data);\n\n      var xs = d3.extent(data, dx).map(Number);\n      var ys = d3.keys(index);\n      var xd = d3.range(xs[0], xs[1] + 1);\n      var layers = ys.map(function(y) {\n        return xd.map(function(x) {\n          var z = index[y][x] || 0;\n          if (stacked && z < 0) z = 0;\n          return {\n            x: x,\n            y: z,\n            key: y\n          };\n        });\n      });\n\n      layers.forEach(function(d) {\n        d.key = d[0].key;\n        d.sum = d3.sum(d, getter('y'));\n      });\n\n      layers.sort(function(a, b) {\n        return d3.descending(a.sum, b.sum);\n      });\n\n      var aggr = stacked ? d3.sum : d3.max;\n      var yd = d3.extent(xd, function(x, i) {\n        return aggr(layers, function(d) {\n          return d[i].y;\n        });\n      });\n\n      var y0 = height - margin.bottom;\n      var y1 = margin.top;\n\n      var y = log\n        ? d3.scale.log()\n          .domain([1, yd[1]])\n          .range([y0, y1])\n          .clamp(true)\n        : d3.scale.linear()\n          .domain([0, yd[1]])\n          .range([y0, y1]);\n      y.nice();\n\n      var x = d3.scale.linear()\n        .domain(d3.extent(data, dx))\n        .range([margin.left, width - margin.right]);\n\n      var yAxis = d3.svg.axis()\n        .orient('left')\n        .scale(y);\n\n      var si = d3.format('s');\n      var suffix = {K: 'k', M: 'm', G: 'b'};\n      var ticks = 3;\n      var yFormat = function(n, i) {\n        var p = (i === 0 || i === ticks) ? '$' : '';\n        return p + si(n).replace(/[KMG]$/, function(s) {\n          return suffix[s] || s;\n        });\n      };\n\n      if (log) {\n        ticks -= 1;\n        yAxis.ticks(ticks, yFormat);\n      } else {\n        yAxis.ticks(ticks)\n          .tickFormat(yFormat);\n      }\n\n      svg.append('g')\n        .attr('class', 'axis y')\n        .attr('transform', 'translate(' + [margin.left - axisSpacing, 0] + ')')\n        .call(yAxis);\n\n      svg.append('g')\n        .attr('class', 'axis x')\n        .attr('transform', 'translate(' + [0, height - margin.bottom + axisSpacing] + ')')\n        .call(d3.svg.axis()\n          .orient('bottom')\n          .scale(x)\n          .tickFormat(d3.format('d')));\n\n      var stack = d3.layout.stack();\n\n      var g = svg.selectAll('g.layer')\n        .data(stack(layers))\n        .enter()\n        .append('g')\n          .attr('class', 'layer')\n          .append('a');\n\n      var area = d3.svg.area()\n        .interpolate(interpolate)\n        .x(function(d) { return x(d.x); });\n\n      if (stacked) {\n        area\n          .y0(function(d) { return y(d.y0); })\n          .y1(function(d) { return y(d.y + d.y0); });\n      } else {\n        area\n          .y0(y(0))\n          .y1(function(d) { return y(d.y); });\n      }\n\n      var paths = g.append('path')\n        .attr('fill', function(d) {\n          return fill(d.key);\n        })\n        .attr('d', area);\n\n      if (voronoi) {\n        var points = [];\n        paths.each(function(d) {\n          d.forEach(function(v) {\n            points.push({\n              data: d,\n              value: v,\n              x: x(v.x),\n              y: y(v.y)\n            });\n          });\n        });\n\n        var vor = eiti.charts.voronoi()\n          .points(points)\n          .clipExtent([\n            [margin.left - axisSpacing, margin.top],\n            [width - margin.right + axisSpacing, height - margin.bottom + axisSpacing]\n          ]);\n\n        var regions = svg.append('g')\n          .attr('class', 'voronoi')\n          .call(vor)\n          .selectAll('*')\n            // NB: you have to do this to revert the data \"back\"\n            // to its pre-voronoi() state\n            .datum(function(d) {\n              return d.point.value;\n            });\n      }\n    };\n\n    /**\n     * Get or set the chart's margin in pixels.\n     *\n     * @example\n     * var margin = areaChart.margin();\n     * areaChart.margin({top: 0, right: 20, bottom: 30, left: 10});\n     * areaChart.margin([0, 100]); // NB: [y, x]\n     * areaChart.margin(20); // 20 on all sides\n     *\n     * @param {*=} margin set the margin as returned by {@link eiti.ui.margin}.\n     */\n    areaChart.margin = function(_) {\n      if (!arguments.length) return margin;\n      margin = eiti.ui.margin(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's horizontal value accessor.\n     *\n     * @example\n     * var x = areaChart.x();\n     * areaChart.x(function(d) { return d.Year; });\n     * areaChart.x('Year'); // same as above\n     *\n     * @param {String|Function=} x set the horizontal value accessor\n     */\n    areaChart.x = function(_) {\n      if (!arguments.length) return dx;\n      dx = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's *layer group* accessor.\n     *\n     * @example\n     * var y = areaChart.y();\n     * areaChart.y(function(d) { return d.Commodity; });\n     * areaChart.y('Commodity'); // same as above\n     *\n     * @param {String|Function=} y set the layer group accessor\n     */\n    areaChart.y = function(_) {\n      if (!arguments.length) return dy;\n      dy = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's vertical (numeric) value accessor.\n     *\n     * @example\n     * var value = areaChart.value();\n     * areaChart.value(function(d) { return d.Revenue; });\n     * areaChart.value('Revenue'); // same as above\n     *\n     * @param {String|Function=} v set the vertical value accessor\n     */\n    areaChart.value = function(_) {\n      if (!arguments.length) return value;\n      value = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle stacking layout. Area charts are not stacked by\n     * default.\n     *\n     * @example\n     * var stacked = areaChart.stacked();\n     * areaChart.stacked(true); // tell it to stack\n     *\n     * @param {Boolean=} stacked if `true`, enabled stacking layout\n     */\n    areaChart.stacked = function(_) {\n      if (!arguments.length) return stacked;\n      stacked = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Toggle logarithmic y-axis scaling.\n     *\n     * @example\n     * var log = areaChart.log();\n     * areaChart.log(true); // use logarithmic scaling\n     *\n     * @param {Boolean=} log if `true`, enabled logarithmic scaling\n     */\n    areaChart.log = function(_) {\n      if (!arguments.length) return log;\n      log = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Get or set the layer fill accessor.\n     *\n     * @example\n     * var fill = areaChart.fill();\n     * areaChart.fill(d3.scale.category20());\n     * areaChart.fill(function(d, i) {\n     *   return i % 2 ? 'yellow' : 'orange';\n     * });\n     * areaChart.fill('red');\n     *\n     * @param {*=} fill set the fill accessor\n     */\n    areaChart.fill = function(_) {\n      if (!arguments.length) return fill;\n      fill = d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle creation of Voronoi regions for interactivity.\n     *\n     * @param {Boolean=} voronoi if `true`, voronoi regions will be created\n     */\n    areaChart.voronoi = function(_) {\n      if (!arguments.length) return voronoi;\n      voronoi = _;\n      return areaChart;\n    };\n\n    return areaChart;\n  }"
          },
          "examples": [
            "<span class=\"hljs-keyword\">var</span> y = areaChart.y();\nareaChart.y(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(d)</span> </span>{ <span class=\"hljs-keyword\">return</span> d.Commodity; });\nareaChart.y(<span class=\"hljs-string\">'Commodity'</span>); <span class=\"hljs-comment\">// same as above</span>"
          ],
          "params": [
            {
              "title": "param",
              "description": "set the layer group accessor",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "UnionType",
                  "elements": [
                    {
                      "type": "NameExpression",
                      "name": "String"
                    },
                    {
                      "type": "NameExpression",
                      "name": "Function"
                    }
                  ]
                }
              },
              "name": "y"
            }
          ],
          "name": "y",
          "kind": "function",
          "memberof": "areaChart",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "areaChart",
            "y"
          ]
        },
        {
          "description": "Get or set the chart's horizontal value accessor.",
          "tags": [
            {
              "title": "example",
              "description": "var x = areaChart.x();\nareaChart.x(function(d) { return d.Year; });\nareaChart.x('Year'); // same as above"
            },
            {
              "title": "param",
              "description": "set the horizontal value accessor",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "UnionType",
                  "elements": [
                    {
                      "type": "NameExpression",
                      "name": "String"
                    },
                    {
                      "type": "NameExpression",
                      "name": "Function"
                    }
                  ]
                }
              },
              "name": "x"
            },
            {
              "title": "name",
              "name": "x"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "areaChart"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 247,
                "column": 4
              },
              "end": {
                "line": 253,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.charts.js",
            "code": "{\n    var dx = getter('Year');\n    var dy = getter('Commodity');\n    var value = getter('Revenue');\n    var stacked = false;\n    var log = false;\n\n    var width = 960;\n    var height = 100;\n\n    var margin = {\n      top: 10,\n      bottom: 25,\n      left: 50,\n      right: 20\n    };\n\n    var axisSpacing = 5;\n\n    var fill = d3.scale.category10();\n    var interpolate = 'cardinal';\n\n    var voronoi = false;\n\n    /**\n     * Renders a chart in a given d3 selection. Use {@link\n     * eiti.charts.area} to create one.\n     *\n     * @namespace areaChart\n     * @param {d3.selection} svg  a d3 `<svg>` element selection\n     * @param {Array=} data optional data\n     */\n    var areaChart = function(svg, data) {\n      if (data) {\n        svg.datum(data);\n      } else {\n        data = svg.datum() || [];\n      }\n      svg.attr('viewBox', [0, 0, width, height].join(' '));\n\n      var index = d3.nest()\n        .key(dy)\n        .key(dx)\n        .rollup(function(d) {\n          return d3.sum(d, value);\n        })\n        .map(data);\n\n      var xs = d3.extent(data, dx).map(Number);\n      var ys = d3.keys(index);\n      var xd = d3.range(xs[0], xs[1] + 1);\n      var layers = ys.map(function(y) {\n        return xd.map(function(x) {\n          var z = index[y][x] || 0;\n          if (stacked && z < 0) z = 0;\n          return {\n            x: x,\n            y: z,\n            key: y\n          };\n        });\n      });\n\n      layers.forEach(function(d) {\n        d.key = d[0].key;\n        d.sum = d3.sum(d, getter('y'));\n      });\n\n      layers.sort(function(a, b) {\n        return d3.descending(a.sum, b.sum);\n      });\n\n      var aggr = stacked ? d3.sum : d3.max;\n      var yd = d3.extent(xd, function(x, i) {\n        return aggr(layers, function(d) {\n          return d[i].y;\n        });\n      });\n\n      var y0 = height - margin.bottom;\n      var y1 = margin.top;\n\n      var y = log\n        ? d3.scale.log()\n          .domain([1, yd[1]])\n          .range([y0, y1])\n          .clamp(true)\n        : d3.scale.linear()\n          .domain([0, yd[1]])\n          .range([y0, y1]);\n      y.nice();\n\n      var x = d3.scale.linear()\n        .domain(d3.extent(data, dx))\n        .range([margin.left, width - margin.right]);\n\n      var yAxis = d3.svg.axis()\n        .orient('left')\n        .scale(y);\n\n      var si = d3.format('s');\n      var suffix = {K: 'k', M: 'm', G: 'b'};\n      var ticks = 3;\n      var yFormat = function(n, i) {\n        var p = (i === 0 || i === ticks) ? '$' : '';\n        return p + si(n).replace(/[KMG]$/, function(s) {\n          return suffix[s] || s;\n        });\n      };\n\n      if (log) {\n        ticks -= 1;\n        yAxis.ticks(ticks, yFormat);\n      } else {\n        yAxis.ticks(ticks)\n          .tickFormat(yFormat);\n      }\n\n      svg.append('g')\n        .attr('class', 'axis y')\n        .attr('transform', 'translate(' + [margin.left - axisSpacing, 0] + ')')\n        .call(yAxis);\n\n      svg.append('g')\n        .attr('class', 'axis x')\n        .attr('transform', 'translate(' + [0, height - margin.bottom + axisSpacing] + ')')\n        .call(d3.svg.axis()\n          .orient('bottom')\n          .scale(x)\n          .tickFormat(d3.format('d')));\n\n      var stack = d3.layout.stack();\n\n      var g = svg.selectAll('g.layer')\n        .data(stack(layers))\n        .enter()\n        .append('g')\n          .attr('class', 'layer')\n          .append('a');\n\n      var area = d3.svg.area()\n        .interpolate(interpolate)\n        .x(function(d) { return x(d.x); });\n\n      if (stacked) {\n        area\n          .y0(function(d) { return y(d.y0); })\n          .y1(function(d) { return y(d.y + d.y0); });\n      } else {\n        area\n          .y0(y(0))\n          .y1(function(d) { return y(d.y); });\n      }\n\n      var paths = g.append('path')\n        .attr('fill', function(d) {\n          return fill(d.key);\n        })\n        .attr('d', area);\n\n      if (voronoi) {\n        var points = [];\n        paths.each(function(d) {\n          d.forEach(function(v) {\n            points.push({\n              data: d,\n              value: v,\n              x: x(v.x),\n              y: y(v.y)\n            });\n          });\n        });\n\n        var vor = eiti.charts.voronoi()\n          .points(points)\n          .clipExtent([\n            [margin.left - axisSpacing, margin.top],\n            [width - margin.right + axisSpacing, height - margin.bottom + axisSpacing]\n          ]);\n\n        var regions = svg.append('g')\n          .attr('class', 'voronoi')\n          .call(vor)\n          .selectAll('*')\n            // NB: you have to do this to revert the data \"back\"\n            // to its pre-voronoi() state\n            .datum(function(d) {\n              return d.point.value;\n            });\n      }\n    };\n\n    /**\n     * Get or set the chart's margin in pixels.\n     *\n     * @example\n     * var margin = areaChart.margin();\n     * areaChart.margin({top: 0, right: 20, bottom: 30, left: 10});\n     * areaChart.margin([0, 100]); // NB: [y, x]\n     * areaChart.margin(20); // 20 on all sides\n     *\n     * @param {*=} margin set the margin as returned by {@link eiti.ui.margin}.\n     */\n    areaChart.margin = function(_) {\n      if (!arguments.length) return margin;\n      margin = eiti.ui.margin(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's horizontal value accessor.\n     *\n     * @example\n     * var x = areaChart.x();\n     * areaChart.x(function(d) { return d.Year; });\n     * areaChart.x('Year'); // same as above\n     *\n     * @param {String|Function=} x set the horizontal value accessor\n     */\n    areaChart.x = function(_) {\n      if (!arguments.length) return dx;\n      dx = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's *layer group* accessor.\n     *\n     * @example\n     * var y = areaChart.y();\n     * areaChart.y(function(d) { return d.Commodity; });\n     * areaChart.y('Commodity'); // same as above\n     *\n     * @param {String|Function=} y set the layer group accessor\n     */\n    areaChart.y = function(_) {\n      if (!arguments.length) return dy;\n      dy = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's vertical (numeric) value accessor.\n     *\n     * @example\n     * var value = areaChart.value();\n     * areaChart.value(function(d) { return d.Revenue; });\n     * areaChart.value('Revenue'); // same as above\n     *\n     * @param {String|Function=} v set the vertical value accessor\n     */\n    areaChart.value = function(_) {\n      if (!arguments.length) return value;\n      value = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle stacking layout. Area charts are not stacked by\n     * default.\n     *\n     * @example\n     * var stacked = areaChart.stacked();\n     * areaChart.stacked(true); // tell it to stack\n     *\n     * @param {Boolean=} stacked if `true`, enabled stacking layout\n     */\n    areaChart.stacked = function(_) {\n      if (!arguments.length) return stacked;\n      stacked = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Toggle logarithmic y-axis scaling.\n     *\n     * @example\n     * var log = areaChart.log();\n     * areaChart.log(true); // use logarithmic scaling\n     *\n     * @param {Boolean=} log if `true`, enabled logarithmic scaling\n     */\n    areaChart.log = function(_) {\n      if (!arguments.length) return log;\n      log = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Get or set the layer fill accessor.\n     *\n     * @example\n     * var fill = areaChart.fill();\n     * areaChart.fill(d3.scale.category20());\n     * areaChart.fill(function(d, i) {\n     *   return i % 2 ? 'yellow' : 'orange';\n     * });\n     * areaChart.fill('red');\n     *\n     * @param {*=} fill set the fill accessor\n     */\n    areaChart.fill = function(_) {\n      if (!arguments.length) return fill;\n      fill = d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle creation of Voronoi regions for interactivity.\n     *\n     * @param {Boolean=} voronoi if `true`, voronoi regions will be created\n     */\n    areaChart.voronoi = function(_) {\n      if (!arguments.length) return voronoi;\n      voronoi = _;\n      return areaChart;\n    };\n\n    return areaChart;\n  }"
          },
          "examples": [
            "<span class=\"hljs-keyword\">var</span> x = areaChart.x();\nareaChart.x(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(d)</span> </span>{ <span class=\"hljs-keyword\">return</span> d.Year; });\nareaChart.x(<span class=\"hljs-string\">'Year'</span>); <span class=\"hljs-comment\">// same as above</span>"
          ],
          "params": [
            {
              "title": "param",
              "description": "set the horizontal value accessor",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "UnionType",
                  "elements": [
                    {
                      "type": "NameExpression",
                      "name": "String"
                    },
                    {
                      "type": "NameExpression",
                      "name": "Function"
                    }
                  ]
                }
              },
              "name": "x"
            }
          ],
          "name": "x",
          "kind": "function",
          "memberof": "areaChart",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "areaChart",
            "x"
          ]
        },
        {
          "description": "Toggle creation of Voronoi regions for interactivity.",
          "tags": [
            {
              "title": "param",
              "description": "if `true`, voronoi regions will be created",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "Boolean"
                }
              },
              "name": "voronoi"
            },
            {
              "title": "name",
              "name": "voronoi"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "areaChart"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 346,
                "column": 4
              },
              "end": {
                "line": 350,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.charts.js",
            "code": "{\n    var dx = getter('Year');\n    var dy = getter('Commodity');\n    var value = getter('Revenue');\n    var stacked = false;\n    var log = false;\n\n    var width = 960;\n    var height = 100;\n\n    var margin = {\n      top: 10,\n      bottom: 25,\n      left: 50,\n      right: 20\n    };\n\n    var axisSpacing = 5;\n\n    var fill = d3.scale.category10();\n    var interpolate = 'cardinal';\n\n    var voronoi = false;\n\n    /**\n     * Renders a chart in a given d3 selection. Use {@link\n     * eiti.charts.area} to create one.\n     *\n     * @namespace areaChart\n     * @param {d3.selection} svg  a d3 `<svg>` element selection\n     * @param {Array=} data optional data\n     */\n    var areaChart = function(svg, data) {\n      if (data) {\n        svg.datum(data);\n      } else {\n        data = svg.datum() || [];\n      }\n      svg.attr('viewBox', [0, 0, width, height].join(' '));\n\n      var index = d3.nest()\n        .key(dy)\n        .key(dx)\n        .rollup(function(d) {\n          return d3.sum(d, value);\n        })\n        .map(data);\n\n      var xs = d3.extent(data, dx).map(Number);\n      var ys = d3.keys(index);\n      var xd = d3.range(xs[0], xs[1] + 1);\n      var layers = ys.map(function(y) {\n        return xd.map(function(x) {\n          var z = index[y][x] || 0;\n          if (stacked && z < 0) z = 0;\n          return {\n            x: x,\n            y: z,\n            key: y\n          };\n        });\n      });\n\n      layers.forEach(function(d) {\n        d.key = d[0].key;\n        d.sum = d3.sum(d, getter('y'));\n      });\n\n      layers.sort(function(a, b) {\n        return d3.descending(a.sum, b.sum);\n      });\n\n      var aggr = stacked ? d3.sum : d3.max;\n      var yd = d3.extent(xd, function(x, i) {\n        return aggr(layers, function(d) {\n          return d[i].y;\n        });\n      });\n\n      var y0 = height - margin.bottom;\n      var y1 = margin.top;\n\n      var y = log\n        ? d3.scale.log()\n          .domain([1, yd[1]])\n          .range([y0, y1])\n          .clamp(true)\n        : d3.scale.linear()\n          .domain([0, yd[1]])\n          .range([y0, y1]);\n      y.nice();\n\n      var x = d3.scale.linear()\n        .domain(d3.extent(data, dx))\n        .range([margin.left, width - margin.right]);\n\n      var yAxis = d3.svg.axis()\n        .orient('left')\n        .scale(y);\n\n      var si = d3.format('s');\n      var suffix = {K: 'k', M: 'm', G: 'b'};\n      var ticks = 3;\n      var yFormat = function(n, i) {\n        var p = (i === 0 || i === ticks) ? '$' : '';\n        return p + si(n).replace(/[KMG]$/, function(s) {\n          return suffix[s] || s;\n        });\n      };\n\n      if (log) {\n        ticks -= 1;\n        yAxis.ticks(ticks, yFormat);\n      } else {\n        yAxis.ticks(ticks)\n          .tickFormat(yFormat);\n      }\n\n      svg.append('g')\n        .attr('class', 'axis y')\n        .attr('transform', 'translate(' + [margin.left - axisSpacing, 0] + ')')\n        .call(yAxis);\n\n      svg.append('g')\n        .attr('class', 'axis x')\n        .attr('transform', 'translate(' + [0, height - margin.bottom + axisSpacing] + ')')\n        .call(d3.svg.axis()\n          .orient('bottom')\n          .scale(x)\n          .tickFormat(d3.format('d')));\n\n      var stack = d3.layout.stack();\n\n      var g = svg.selectAll('g.layer')\n        .data(stack(layers))\n        .enter()\n        .append('g')\n          .attr('class', 'layer')\n          .append('a');\n\n      var area = d3.svg.area()\n        .interpolate(interpolate)\n        .x(function(d) { return x(d.x); });\n\n      if (stacked) {\n        area\n          .y0(function(d) { return y(d.y0); })\n          .y1(function(d) { return y(d.y + d.y0); });\n      } else {\n        area\n          .y0(y(0))\n          .y1(function(d) { return y(d.y); });\n      }\n\n      var paths = g.append('path')\n        .attr('fill', function(d) {\n          return fill(d.key);\n        })\n        .attr('d', area);\n\n      if (voronoi) {\n        var points = [];\n        paths.each(function(d) {\n          d.forEach(function(v) {\n            points.push({\n              data: d,\n              value: v,\n              x: x(v.x),\n              y: y(v.y)\n            });\n          });\n        });\n\n        var vor = eiti.charts.voronoi()\n          .points(points)\n          .clipExtent([\n            [margin.left - axisSpacing, margin.top],\n            [width - margin.right + axisSpacing, height - margin.bottom + axisSpacing]\n          ]);\n\n        var regions = svg.append('g')\n          .attr('class', 'voronoi')\n          .call(vor)\n          .selectAll('*')\n            // NB: you have to do this to revert the data \"back\"\n            // to its pre-voronoi() state\n            .datum(function(d) {\n              return d.point.value;\n            });\n      }\n    };\n\n    /**\n     * Get or set the chart's margin in pixels.\n     *\n     * @example\n     * var margin = areaChart.margin();\n     * areaChart.margin({top: 0, right: 20, bottom: 30, left: 10});\n     * areaChart.margin([0, 100]); // NB: [y, x]\n     * areaChart.margin(20); // 20 on all sides\n     *\n     * @param {*=} margin set the margin as returned by {@link eiti.ui.margin}.\n     */\n    areaChart.margin = function(_) {\n      if (!arguments.length) return margin;\n      margin = eiti.ui.margin(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's horizontal value accessor.\n     *\n     * @example\n     * var x = areaChart.x();\n     * areaChart.x(function(d) { return d.Year; });\n     * areaChart.x('Year'); // same as above\n     *\n     * @param {String|Function=} x set the horizontal value accessor\n     */\n    areaChart.x = function(_) {\n      if (!arguments.length) return dx;\n      dx = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's *layer group* accessor.\n     *\n     * @example\n     * var y = areaChart.y();\n     * areaChart.y(function(d) { return d.Commodity; });\n     * areaChart.y('Commodity'); // same as above\n     *\n     * @param {String|Function=} y set the layer group accessor\n     */\n    areaChart.y = function(_) {\n      if (!arguments.length) return dy;\n      dy = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's vertical (numeric) value accessor.\n     *\n     * @example\n     * var value = areaChart.value();\n     * areaChart.value(function(d) { return d.Revenue; });\n     * areaChart.value('Revenue'); // same as above\n     *\n     * @param {String|Function=} v set the vertical value accessor\n     */\n    areaChart.value = function(_) {\n      if (!arguments.length) return value;\n      value = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle stacking layout. Area charts are not stacked by\n     * default.\n     *\n     * @example\n     * var stacked = areaChart.stacked();\n     * areaChart.stacked(true); // tell it to stack\n     *\n     * @param {Boolean=} stacked if `true`, enabled stacking layout\n     */\n    areaChart.stacked = function(_) {\n      if (!arguments.length) return stacked;\n      stacked = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Toggle logarithmic y-axis scaling.\n     *\n     * @example\n     * var log = areaChart.log();\n     * areaChart.log(true); // use logarithmic scaling\n     *\n     * @param {Boolean=} log if `true`, enabled logarithmic scaling\n     */\n    areaChart.log = function(_) {\n      if (!arguments.length) return log;\n      log = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Get or set the layer fill accessor.\n     *\n     * @example\n     * var fill = areaChart.fill();\n     * areaChart.fill(d3.scale.category20());\n     * areaChart.fill(function(d, i) {\n     *   return i % 2 ? 'yellow' : 'orange';\n     * });\n     * areaChart.fill('red');\n     *\n     * @param {*=} fill set the fill accessor\n     */\n    areaChart.fill = function(_) {\n      if (!arguments.length) return fill;\n      fill = d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle creation of Voronoi regions for interactivity.\n     *\n     * @param {Boolean=} voronoi if `true`, voronoi regions will be created\n     */\n    areaChart.voronoi = function(_) {\n      if (!arguments.length) return voronoi;\n      voronoi = _;\n      return areaChart;\n    };\n\n    return areaChart;\n  }"
          },
          "params": [
            {
              "title": "param",
              "description": "if `true`, voronoi regions will be created",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "Boolean"
                }
              },
              "name": "voronoi"
            }
          ],
          "name": "voronoi",
          "kind": "function",
          "memberof": "areaChart",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "areaChart",
            "voronoi"
          ]
        },
        {
          "description": "Get or set the chart's vertical (numeric) value accessor.",
          "tags": [
            {
              "title": "example",
              "description": "var value = areaChart.value();\nareaChart.value(function(d) { return d.Revenue; });\nareaChart.value('Revenue'); // same as above"
            },
            {
              "title": "param",
              "description": "set the vertical value accessor",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "UnionType",
                  "elements": [
                    {
                      "type": "NameExpression",
                      "name": "String"
                    },
                    {
                      "type": "NameExpression",
                      "name": "Function"
                    }
                  ]
                }
              },
              "name": "v"
            },
            {
              "title": "name",
              "name": "value"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "areaChart"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 283,
                "column": 4
              },
              "end": {
                "line": 289,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.charts.js",
            "code": "{\n    var dx = getter('Year');\n    var dy = getter('Commodity');\n    var value = getter('Revenue');\n    var stacked = false;\n    var log = false;\n\n    var width = 960;\n    var height = 100;\n\n    var margin = {\n      top: 10,\n      bottom: 25,\n      left: 50,\n      right: 20\n    };\n\n    var axisSpacing = 5;\n\n    var fill = d3.scale.category10();\n    var interpolate = 'cardinal';\n\n    var voronoi = false;\n\n    /**\n     * Renders a chart in a given d3 selection. Use {@link\n     * eiti.charts.area} to create one.\n     *\n     * @namespace areaChart\n     * @param {d3.selection} svg  a d3 `<svg>` element selection\n     * @param {Array=} data optional data\n     */\n    var areaChart = function(svg, data) {\n      if (data) {\n        svg.datum(data);\n      } else {\n        data = svg.datum() || [];\n      }\n      svg.attr('viewBox', [0, 0, width, height].join(' '));\n\n      var index = d3.nest()\n        .key(dy)\n        .key(dx)\n        .rollup(function(d) {\n          return d3.sum(d, value);\n        })\n        .map(data);\n\n      var xs = d3.extent(data, dx).map(Number);\n      var ys = d3.keys(index);\n      var xd = d3.range(xs[0], xs[1] + 1);\n      var layers = ys.map(function(y) {\n        return xd.map(function(x) {\n          var z = index[y][x] || 0;\n          if (stacked && z < 0) z = 0;\n          return {\n            x: x,\n            y: z,\n            key: y\n          };\n        });\n      });\n\n      layers.forEach(function(d) {\n        d.key = d[0].key;\n        d.sum = d3.sum(d, getter('y'));\n      });\n\n      layers.sort(function(a, b) {\n        return d3.descending(a.sum, b.sum);\n      });\n\n      var aggr = stacked ? d3.sum : d3.max;\n      var yd = d3.extent(xd, function(x, i) {\n        return aggr(layers, function(d) {\n          return d[i].y;\n        });\n      });\n\n      var y0 = height - margin.bottom;\n      var y1 = margin.top;\n\n      var y = log\n        ? d3.scale.log()\n          .domain([1, yd[1]])\n          .range([y0, y1])\n          .clamp(true)\n        : d3.scale.linear()\n          .domain([0, yd[1]])\n          .range([y0, y1]);\n      y.nice();\n\n      var x = d3.scale.linear()\n        .domain(d3.extent(data, dx))\n        .range([margin.left, width - margin.right]);\n\n      var yAxis = d3.svg.axis()\n        .orient('left')\n        .scale(y);\n\n      var si = d3.format('s');\n      var suffix = {K: 'k', M: 'm', G: 'b'};\n      var ticks = 3;\n      var yFormat = function(n, i) {\n        var p = (i === 0 || i === ticks) ? '$' : '';\n        return p + si(n).replace(/[KMG]$/, function(s) {\n          return suffix[s] || s;\n        });\n      };\n\n      if (log) {\n        ticks -= 1;\n        yAxis.ticks(ticks, yFormat);\n      } else {\n        yAxis.ticks(ticks)\n          .tickFormat(yFormat);\n      }\n\n      svg.append('g')\n        .attr('class', 'axis y')\n        .attr('transform', 'translate(' + [margin.left - axisSpacing, 0] + ')')\n        .call(yAxis);\n\n      svg.append('g')\n        .attr('class', 'axis x')\n        .attr('transform', 'translate(' + [0, height - margin.bottom + axisSpacing] + ')')\n        .call(d3.svg.axis()\n          .orient('bottom')\n          .scale(x)\n          .tickFormat(d3.format('d')));\n\n      var stack = d3.layout.stack();\n\n      var g = svg.selectAll('g.layer')\n        .data(stack(layers))\n        .enter()\n        .append('g')\n          .attr('class', 'layer')\n          .append('a');\n\n      var area = d3.svg.area()\n        .interpolate(interpolate)\n        .x(function(d) { return x(d.x); });\n\n      if (stacked) {\n        area\n          .y0(function(d) { return y(d.y0); })\n          .y1(function(d) { return y(d.y + d.y0); });\n      } else {\n        area\n          .y0(y(0))\n          .y1(function(d) { return y(d.y); });\n      }\n\n      var paths = g.append('path')\n        .attr('fill', function(d) {\n          return fill(d.key);\n        })\n        .attr('d', area);\n\n      if (voronoi) {\n        var points = [];\n        paths.each(function(d) {\n          d.forEach(function(v) {\n            points.push({\n              data: d,\n              value: v,\n              x: x(v.x),\n              y: y(v.y)\n            });\n          });\n        });\n\n        var vor = eiti.charts.voronoi()\n          .points(points)\n          .clipExtent([\n            [margin.left - axisSpacing, margin.top],\n            [width - margin.right + axisSpacing, height - margin.bottom + axisSpacing]\n          ]);\n\n        var regions = svg.append('g')\n          .attr('class', 'voronoi')\n          .call(vor)\n          .selectAll('*')\n            // NB: you have to do this to revert the data \"back\"\n            // to its pre-voronoi() state\n            .datum(function(d) {\n              return d.point.value;\n            });\n      }\n    };\n\n    /**\n     * Get or set the chart's margin in pixels.\n     *\n     * @example\n     * var margin = areaChart.margin();\n     * areaChart.margin({top: 0, right: 20, bottom: 30, left: 10});\n     * areaChart.margin([0, 100]); // NB: [y, x]\n     * areaChart.margin(20); // 20 on all sides\n     *\n     * @param {*=} margin set the margin as returned by {@link eiti.ui.margin}.\n     */\n    areaChart.margin = function(_) {\n      if (!arguments.length) return margin;\n      margin = eiti.ui.margin(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's horizontal value accessor.\n     *\n     * @example\n     * var x = areaChart.x();\n     * areaChart.x(function(d) { return d.Year; });\n     * areaChart.x('Year'); // same as above\n     *\n     * @param {String|Function=} x set the horizontal value accessor\n     */\n    areaChart.x = function(_) {\n      if (!arguments.length) return dx;\n      dx = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's *layer group* accessor.\n     *\n     * @example\n     * var y = areaChart.y();\n     * areaChart.y(function(d) { return d.Commodity; });\n     * areaChart.y('Commodity'); // same as above\n     *\n     * @param {String|Function=} y set the layer group accessor\n     */\n    areaChart.y = function(_) {\n      if (!arguments.length) return dy;\n      dy = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's vertical (numeric) value accessor.\n     *\n     * @example\n     * var value = areaChart.value();\n     * areaChart.value(function(d) { return d.Revenue; });\n     * areaChart.value('Revenue'); // same as above\n     *\n     * @param {String|Function=} v set the vertical value accessor\n     */\n    areaChart.value = function(_) {\n      if (!arguments.length) return value;\n      value = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle stacking layout. Area charts are not stacked by\n     * default.\n     *\n     * @example\n     * var stacked = areaChart.stacked();\n     * areaChart.stacked(true); // tell it to stack\n     *\n     * @param {Boolean=} stacked if `true`, enabled stacking layout\n     */\n    areaChart.stacked = function(_) {\n      if (!arguments.length) return stacked;\n      stacked = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Toggle logarithmic y-axis scaling.\n     *\n     * @example\n     * var log = areaChart.log();\n     * areaChart.log(true); // use logarithmic scaling\n     *\n     * @param {Boolean=} log if `true`, enabled logarithmic scaling\n     */\n    areaChart.log = function(_) {\n      if (!arguments.length) return log;\n      log = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Get or set the layer fill accessor.\n     *\n     * @example\n     * var fill = areaChart.fill();\n     * areaChart.fill(d3.scale.category20());\n     * areaChart.fill(function(d, i) {\n     *   return i % 2 ? 'yellow' : 'orange';\n     * });\n     * areaChart.fill('red');\n     *\n     * @param {*=} fill set the fill accessor\n     */\n    areaChart.fill = function(_) {\n      if (!arguments.length) return fill;\n      fill = d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle creation of Voronoi regions for interactivity.\n     *\n     * @param {Boolean=} voronoi if `true`, voronoi regions will be created\n     */\n    areaChart.voronoi = function(_) {\n      if (!arguments.length) return voronoi;\n      voronoi = _;\n      return areaChart;\n    };\n\n    return areaChart;\n  }"
          },
          "examples": [
            "<span class=\"hljs-keyword\">var</span> value = areaChart.value();\nareaChart.value(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(d)</span> </span>{ <span class=\"hljs-keyword\">return</span> d.Revenue; });\nareaChart.value(<span class=\"hljs-string\">'Revenue'</span>); <span class=\"hljs-comment\">// same as above</span>"
          ],
          "params": [
            {
              "title": "param",
              "description": "set the vertical value accessor",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "UnionType",
                  "elements": [
                    {
                      "type": "NameExpression",
                      "name": "String"
                    },
                    {
                      "type": "NameExpression",
                      "name": "Function"
                    }
                  ]
                }
              },
              "name": "v"
            }
          ],
          "name": "value",
          "kind": "function",
          "memberof": "areaChart",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "areaChart",
            "value"
          ]
        },
        {
          "description": "Toggle stacking layout. Area charts are not stacked by\ndefault.",
          "tags": [
            {
              "title": "example",
              "description": "var stacked = areaChart.stacked();\nareaChart.stacked(true); // tell it to stack"
            },
            {
              "title": "param",
              "description": "if `true`, enabled stacking layout",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "Boolean"
                }
              },
              "name": "stacked"
            },
            {
              "title": "name",
              "name": "stacked"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "areaChart"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 301,
                "column": 4
              },
              "end": {
                "line": 305,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.charts.js",
            "code": "{\n    var dx = getter('Year');\n    var dy = getter('Commodity');\n    var value = getter('Revenue');\n    var stacked = false;\n    var log = false;\n\n    var width = 960;\n    var height = 100;\n\n    var margin = {\n      top: 10,\n      bottom: 25,\n      left: 50,\n      right: 20\n    };\n\n    var axisSpacing = 5;\n\n    var fill = d3.scale.category10();\n    var interpolate = 'cardinal';\n\n    var voronoi = false;\n\n    /**\n     * Renders a chart in a given d3 selection. Use {@link\n     * eiti.charts.area} to create one.\n     *\n     * @namespace areaChart\n     * @param {d3.selection} svg  a d3 `<svg>` element selection\n     * @param {Array=} data optional data\n     */\n    var areaChart = function(svg, data) {\n      if (data) {\n        svg.datum(data);\n      } else {\n        data = svg.datum() || [];\n      }\n      svg.attr('viewBox', [0, 0, width, height].join(' '));\n\n      var index = d3.nest()\n        .key(dy)\n        .key(dx)\n        .rollup(function(d) {\n          return d3.sum(d, value);\n        })\n        .map(data);\n\n      var xs = d3.extent(data, dx).map(Number);\n      var ys = d3.keys(index);\n      var xd = d3.range(xs[0], xs[1] + 1);\n      var layers = ys.map(function(y) {\n        return xd.map(function(x) {\n          var z = index[y][x] || 0;\n          if (stacked && z < 0) z = 0;\n          return {\n            x: x,\n            y: z,\n            key: y\n          };\n        });\n      });\n\n      layers.forEach(function(d) {\n        d.key = d[0].key;\n        d.sum = d3.sum(d, getter('y'));\n      });\n\n      layers.sort(function(a, b) {\n        return d3.descending(a.sum, b.sum);\n      });\n\n      var aggr = stacked ? d3.sum : d3.max;\n      var yd = d3.extent(xd, function(x, i) {\n        return aggr(layers, function(d) {\n          return d[i].y;\n        });\n      });\n\n      var y0 = height - margin.bottom;\n      var y1 = margin.top;\n\n      var y = log\n        ? d3.scale.log()\n          .domain([1, yd[1]])\n          .range([y0, y1])\n          .clamp(true)\n        : d3.scale.linear()\n          .domain([0, yd[1]])\n          .range([y0, y1]);\n      y.nice();\n\n      var x = d3.scale.linear()\n        .domain(d3.extent(data, dx))\n        .range([margin.left, width - margin.right]);\n\n      var yAxis = d3.svg.axis()\n        .orient('left')\n        .scale(y);\n\n      var si = d3.format('s');\n      var suffix = {K: 'k', M: 'm', G: 'b'};\n      var ticks = 3;\n      var yFormat = function(n, i) {\n        var p = (i === 0 || i === ticks) ? '$' : '';\n        return p + si(n).replace(/[KMG]$/, function(s) {\n          return suffix[s] || s;\n        });\n      };\n\n      if (log) {\n        ticks -= 1;\n        yAxis.ticks(ticks, yFormat);\n      } else {\n        yAxis.ticks(ticks)\n          .tickFormat(yFormat);\n      }\n\n      svg.append('g')\n        .attr('class', 'axis y')\n        .attr('transform', 'translate(' + [margin.left - axisSpacing, 0] + ')')\n        .call(yAxis);\n\n      svg.append('g')\n        .attr('class', 'axis x')\n        .attr('transform', 'translate(' + [0, height - margin.bottom + axisSpacing] + ')')\n        .call(d3.svg.axis()\n          .orient('bottom')\n          .scale(x)\n          .tickFormat(d3.format('d')));\n\n      var stack = d3.layout.stack();\n\n      var g = svg.selectAll('g.layer')\n        .data(stack(layers))\n        .enter()\n        .append('g')\n          .attr('class', 'layer')\n          .append('a');\n\n      var area = d3.svg.area()\n        .interpolate(interpolate)\n        .x(function(d) { return x(d.x); });\n\n      if (stacked) {\n        area\n          .y0(function(d) { return y(d.y0); })\n          .y1(function(d) { return y(d.y + d.y0); });\n      } else {\n        area\n          .y0(y(0))\n          .y1(function(d) { return y(d.y); });\n      }\n\n      var paths = g.append('path')\n        .attr('fill', function(d) {\n          return fill(d.key);\n        })\n        .attr('d', area);\n\n      if (voronoi) {\n        var points = [];\n        paths.each(function(d) {\n          d.forEach(function(v) {\n            points.push({\n              data: d,\n              value: v,\n              x: x(v.x),\n              y: y(v.y)\n            });\n          });\n        });\n\n        var vor = eiti.charts.voronoi()\n          .points(points)\n          .clipExtent([\n            [margin.left - axisSpacing, margin.top],\n            [width - margin.right + axisSpacing, height - margin.bottom + axisSpacing]\n          ]);\n\n        var regions = svg.append('g')\n          .attr('class', 'voronoi')\n          .call(vor)\n          .selectAll('*')\n            // NB: you have to do this to revert the data \"back\"\n            // to its pre-voronoi() state\n            .datum(function(d) {\n              return d.point.value;\n            });\n      }\n    };\n\n    /**\n     * Get or set the chart's margin in pixels.\n     *\n     * @example\n     * var margin = areaChart.margin();\n     * areaChart.margin({top: 0, right: 20, bottom: 30, left: 10});\n     * areaChart.margin([0, 100]); // NB: [y, x]\n     * areaChart.margin(20); // 20 on all sides\n     *\n     * @param {*=} margin set the margin as returned by {@link eiti.ui.margin}.\n     */\n    areaChart.margin = function(_) {\n      if (!arguments.length) return margin;\n      margin = eiti.ui.margin(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's horizontal value accessor.\n     *\n     * @example\n     * var x = areaChart.x();\n     * areaChart.x(function(d) { return d.Year; });\n     * areaChart.x('Year'); // same as above\n     *\n     * @param {String|Function=} x set the horizontal value accessor\n     */\n    areaChart.x = function(_) {\n      if (!arguments.length) return dx;\n      dx = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's *layer group* accessor.\n     *\n     * @example\n     * var y = areaChart.y();\n     * areaChart.y(function(d) { return d.Commodity; });\n     * areaChart.y('Commodity'); // same as above\n     *\n     * @param {String|Function=} y set the layer group accessor\n     */\n    areaChart.y = function(_) {\n      if (!arguments.length) return dy;\n      dy = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's vertical (numeric) value accessor.\n     *\n     * @example\n     * var value = areaChart.value();\n     * areaChart.value(function(d) { return d.Revenue; });\n     * areaChart.value('Revenue'); // same as above\n     *\n     * @param {String|Function=} v set the vertical value accessor\n     */\n    areaChart.value = function(_) {\n      if (!arguments.length) return value;\n      value = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle stacking layout. Area charts are not stacked by\n     * default.\n     *\n     * @example\n     * var stacked = areaChart.stacked();\n     * areaChart.stacked(true); // tell it to stack\n     *\n     * @param {Boolean=} stacked if `true`, enabled stacking layout\n     */\n    areaChart.stacked = function(_) {\n      if (!arguments.length) return stacked;\n      stacked = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Toggle logarithmic y-axis scaling.\n     *\n     * @example\n     * var log = areaChart.log();\n     * areaChart.log(true); // use logarithmic scaling\n     *\n     * @param {Boolean=} log if `true`, enabled logarithmic scaling\n     */\n    areaChart.log = function(_) {\n      if (!arguments.length) return log;\n      log = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Get or set the layer fill accessor.\n     *\n     * @example\n     * var fill = areaChart.fill();\n     * areaChart.fill(d3.scale.category20());\n     * areaChart.fill(function(d, i) {\n     *   return i % 2 ? 'yellow' : 'orange';\n     * });\n     * areaChart.fill('red');\n     *\n     * @param {*=} fill set the fill accessor\n     */\n    areaChart.fill = function(_) {\n      if (!arguments.length) return fill;\n      fill = d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle creation of Voronoi regions for interactivity.\n     *\n     * @param {Boolean=} voronoi if `true`, voronoi regions will be created\n     */\n    areaChart.voronoi = function(_) {\n      if (!arguments.length) return voronoi;\n      voronoi = _;\n      return areaChart;\n    };\n\n    return areaChart;\n  }"
          },
          "examples": [
            "<span class=\"hljs-keyword\">var</span> stacked = areaChart.stacked();\nareaChart.stacked(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// tell it to stack</span>"
          ],
          "params": [
            {
              "title": "param",
              "description": "if `true`, enabled stacking layout",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "Boolean"
                }
              },
              "name": "stacked"
            }
          ],
          "name": "stacked",
          "kind": "function",
          "memberof": "areaChart",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "areaChart",
            "stacked"
          ]
        },
        {
          "description": "Get or set the chart's margin in pixels.",
          "tags": [
            {
              "title": "example",
              "description": "var margin = areaChart.margin();\nareaChart.margin({top: 0, right: 20, bottom: 30, left: 10});\nareaChart.margin([0, 100]); // NB: [y, x]\nareaChart.margin(20); // 20 on all sides"
            },
            {
              "title": "param",
              "description": "set the margin as returned by {@link eiti.ui.margin}.",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "AllLiteral"
                }
              },
              "name": "margin"
            },
            {
              "title": "name",
              "name": "margin"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "areaChart"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 231,
                "column": 4
              },
              "end": {
                "line": 235,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.charts.js",
            "code": "{\n    var dx = getter('Year');\n    var dy = getter('Commodity');\n    var value = getter('Revenue');\n    var stacked = false;\n    var log = false;\n\n    var width = 960;\n    var height = 100;\n\n    var margin = {\n      top: 10,\n      bottom: 25,\n      left: 50,\n      right: 20\n    };\n\n    var axisSpacing = 5;\n\n    var fill = d3.scale.category10();\n    var interpolate = 'cardinal';\n\n    var voronoi = false;\n\n    /**\n     * Renders a chart in a given d3 selection. Use {@link\n     * eiti.charts.area} to create one.\n     *\n     * @namespace areaChart\n     * @param {d3.selection} svg  a d3 `<svg>` element selection\n     * @param {Array=} data optional data\n     */\n    var areaChart = function(svg, data) {\n      if (data) {\n        svg.datum(data);\n      } else {\n        data = svg.datum() || [];\n      }\n      svg.attr('viewBox', [0, 0, width, height].join(' '));\n\n      var index = d3.nest()\n        .key(dy)\n        .key(dx)\n        .rollup(function(d) {\n          return d3.sum(d, value);\n        })\n        .map(data);\n\n      var xs = d3.extent(data, dx).map(Number);\n      var ys = d3.keys(index);\n      var xd = d3.range(xs[0], xs[1] + 1);\n      var layers = ys.map(function(y) {\n        return xd.map(function(x) {\n          var z = index[y][x] || 0;\n          if (stacked && z < 0) z = 0;\n          return {\n            x: x,\n            y: z,\n            key: y\n          };\n        });\n      });\n\n      layers.forEach(function(d) {\n        d.key = d[0].key;\n        d.sum = d3.sum(d, getter('y'));\n      });\n\n      layers.sort(function(a, b) {\n        return d3.descending(a.sum, b.sum);\n      });\n\n      var aggr = stacked ? d3.sum : d3.max;\n      var yd = d3.extent(xd, function(x, i) {\n        return aggr(layers, function(d) {\n          return d[i].y;\n        });\n      });\n\n      var y0 = height - margin.bottom;\n      var y1 = margin.top;\n\n      var y = log\n        ? d3.scale.log()\n          .domain([1, yd[1]])\n          .range([y0, y1])\n          .clamp(true)\n        : d3.scale.linear()\n          .domain([0, yd[1]])\n          .range([y0, y1]);\n      y.nice();\n\n      var x = d3.scale.linear()\n        .domain(d3.extent(data, dx))\n        .range([margin.left, width - margin.right]);\n\n      var yAxis = d3.svg.axis()\n        .orient('left')\n        .scale(y);\n\n      var si = d3.format('s');\n      var suffix = {K: 'k', M: 'm', G: 'b'};\n      var ticks = 3;\n      var yFormat = function(n, i) {\n        var p = (i === 0 || i === ticks) ? '$' : '';\n        return p + si(n).replace(/[KMG]$/, function(s) {\n          return suffix[s] || s;\n        });\n      };\n\n      if (log) {\n        ticks -= 1;\n        yAxis.ticks(ticks, yFormat);\n      } else {\n        yAxis.ticks(ticks)\n          .tickFormat(yFormat);\n      }\n\n      svg.append('g')\n        .attr('class', 'axis y')\n        .attr('transform', 'translate(' + [margin.left - axisSpacing, 0] + ')')\n        .call(yAxis);\n\n      svg.append('g')\n        .attr('class', 'axis x')\n        .attr('transform', 'translate(' + [0, height - margin.bottom + axisSpacing] + ')')\n        .call(d3.svg.axis()\n          .orient('bottom')\n          .scale(x)\n          .tickFormat(d3.format('d')));\n\n      var stack = d3.layout.stack();\n\n      var g = svg.selectAll('g.layer')\n        .data(stack(layers))\n        .enter()\n        .append('g')\n          .attr('class', 'layer')\n          .append('a');\n\n      var area = d3.svg.area()\n        .interpolate(interpolate)\n        .x(function(d) { return x(d.x); });\n\n      if (stacked) {\n        area\n          .y0(function(d) { return y(d.y0); })\n          .y1(function(d) { return y(d.y + d.y0); });\n      } else {\n        area\n          .y0(y(0))\n          .y1(function(d) { return y(d.y); });\n      }\n\n      var paths = g.append('path')\n        .attr('fill', function(d) {\n          return fill(d.key);\n        })\n        .attr('d', area);\n\n      if (voronoi) {\n        var points = [];\n        paths.each(function(d) {\n          d.forEach(function(v) {\n            points.push({\n              data: d,\n              value: v,\n              x: x(v.x),\n              y: y(v.y)\n            });\n          });\n        });\n\n        var vor = eiti.charts.voronoi()\n          .points(points)\n          .clipExtent([\n            [margin.left - axisSpacing, margin.top],\n            [width - margin.right + axisSpacing, height - margin.bottom + axisSpacing]\n          ]);\n\n        var regions = svg.append('g')\n          .attr('class', 'voronoi')\n          .call(vor)\n          .selectAll('*')\n            // NB: you have to do this to revert the data \"back\"\n            // to its pre-voronoi() state\n            .datum(function(d) {\n              return d.point.value;\n            });\n      }\n    };\n\n    /**\n     * Get or set the chart's margin in pixels.\n     *\n     * @example\n     * var margin = areaChart.margin();\n     * areaChart.margin({top: 0, right: 20, bottom: 30, left: 10});\n     * areaChart.margin([0, 100]); // NB: [y, x]\n     * areaChart.margin(20); // 20 on all sides\n     *\n     * @param {*=} margin set the margin as returned by {@link eiti.ui.margin}.\n     */\n    areaChart.margin = function(_) {\n      if (!arguments.length) return margin;\n      margin = eiti.ui.margin(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's horizontal value accessor.\n     *\n     * @example\n     * var x = areaChart.x();\n     * areaChart.x(function(d) { return d.Year; });\n     * areaChart.x('Year'); // same as above\n     *\n     * @param {String|Function=} x set the horizontal value accessor\n     */\n    areaChart.x = function(_) {\n      if (!arguments.length) return dx;\n      dx = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's *layer group* accessor.\n     *\n     * @example\n     * var y = areaChart.y();\n     * areaChart.y(function(d) { return d.Commodity; });\n     * areaChart.y('Commodity'); // same as above\n     *\n     * @param {String|Function=} y set the layer group accessor\n     */\n    areaChart.y = function(_) {\n      if (!arguments.length) return dy;\n      dy = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's vertical (numeric) value accessor.\n     *\n     * @example\n     * var value = areaChart.value();\n     * areaChart.value(function(d) { return d.Revenue; });\n     * areaChart.value('Revenue'); // same as above\n     *\n     * @param {String|Function=} v set the vertical value accessor\n     */\n    areaChart.value = function(_) {\n      if (!arguments.length) return value;\n      value = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle stacking layout. Area charts are not stacked by\n     * default.\n     *\n     * @example\n     * var stacked = areaChart.stacked();\n     * areaChart.stacked(true); // tell it to stack\n     *\n     * @param {Boolean=} stacked if `true`, enabled stacking layout\n     */\n    areaChart.stacked = function(_) {\n      if (!arguments.length) return stacked;\n      stacked = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Toggle logarithmic y-axis scaling.\n     *\n     * @example\n     * var log = areaChart.log();\n     * areaChart.log(true); // use logarithmic scaling\n     *\n     * @param {Boolean=} log if `true`, enabled logarithmic scaling\n     */\n    areaChart.log = function(_) {\n      if (!arguments.length) return log;\n      log = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Get or set the layer fill accessor.\n     *\n     * @example\n     * var fill = areaChart.fill();\n     * areaChart.fill(d3.scale.category20());\n     * areaChart.fill(function(d, i) {\n     *   return i % 2 ? 'yellow' : 'orange';\n     * });\n     * areaChart.fill('red');\n     *\n     * @param {*=} fill set the fill accessor\n     */\n    areaChart.fill = function(_) {\n      if (!arguments.length) return fill;\n      fill = d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle creation of Voronoi regions for interactivity.\n     *\n     * @param {Boolean=} voronoi if `true`, voronoi regions will be created\n     */\n    areaChart.voronoi = function(_) {\n      if (!arguments.length) return voronoi;\n      voronoi = _;\n      return areaChart;\n    };\n\n    return areaChart;\n  }"
          },
          "examples": [
            "<span class=\"hljs-keyword\">var</span> margin = areaChart.margin();\nareaChart.margin({top: <span class=\"hljs-number\">0</span>, right: <span class=\"hljs-number\">20</span>, bottom: <span class=\"hljs-number\">30</span>, left: <span class=\"hljs-number\">10</span>});\nareaChart.margin([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>]); <span class=\"hljs-comment\">// NB: [y, x]</span>\nareaChart.margin(<span class=\"hljs-number\">20</span>); <span class=\"hljs-comment\">// 20 on all sides</span>"
          ],
          "params": [
            {
              "title": "param",
              "description": "set the margin as returned by {@link eiti.ui.margin}.",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "AllLiteral"
                }
              },
              "name": "margin"
            }
          ],
          "name": "margin",
          "kind": "function",
          "memberof": "areaChart",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "areaChart",
            "margin"
          ]
        },
        {
          "description": "Toggle logarithmic y-axis scaling.",
          "tags": [
            {
              "title": "example",
              "description": "var log = areaChart.log();\nareaChart.log(true); // use logarithmic scaling"
            },
            {
              "title": "param",
              "description": "if `true`, enabled logarithmic scaling",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "Boolean"
                }
              },
              "name": "log"
            },
            {
              "title": "name",
              "name": "log"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "areaChart"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 316,
                "column": 4
              },
              "end": {
                "line": 320,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.charts.js",
            "code": "{\n    var dx = getter('Year');\n    var dy = getter('Commodity');\n    var value = getter('Revenue');\n    var stacked = false;\n    var log = false;\n\n    var width = 960;\n    var height = 100;\n\n    var margin = {\n      top: 10,\n      bottom: 25,\n      left: 50,\n      right: 20\n    };\n\n    var axisSpacing = 5;\n\n    var fill = d3.scale.category10();\n    var interpolate = 'cardinal';\n\n    var voronoi = false;\n\n    /**\n     * Renders a chart in a given d3 selection. Use {@link\n     * eiti.charts.area} to create one.\n     *\n     * @namespace areaChart\n     * @param {d3.selection} svg  a d3 `<svg>` element selection\n     * @param {Array=} data optional data\n     */\n    var areaChart = function(svg, data) {\n      if (data) {\n        svg.datum(data);\n      } else {\n        data = svg.datum() || [];\n      }\n      svg.attr('viewBox', [0, 0, width, height].join(' '));\n\n      var index = d3.nest()\n        .key(dy)\n        .key(dx)\n        .rollup(function(d) {\n          return d3.sum(d, value);\n        })\n        .map(data);\n\n      var xs = d3.extent(data, dx).map(Number);\n      var ys = d3.keys(index);\n      var xd = d3.range(xs[0], xs[1] + 1);\n      var layers = ys.map(function(y) {\n        return xd.map(function(x) {\n          var z = index[y][x] || 0;\n          if (stacked && z < 0) z = 0;\n          return {\n            x: x,\n            y: z,\n            key: y\n          };\n        });\n      });\n\n      layers.forEach(function(d) {\n        d.key = d[0].key;\n        d.sum = d3.sum(d, getter('y'));\n      });\n\n      layers.sort(function(a, b) {\n        return d3.descending(a.sum, b.sum);\n      });\n\n      var aggr = stacked ? d3.sum : d3.max;\n      var yd = d3.extent(xd, function(x, i) {\n        return aggr(layers, function(d) {\n          return d[i].y;\n        });\n      });\n\n      var y0 = height - margin.bottom;\n      var y1 = margin.top;\n\n      var y = log\n        ? d3.scale.log()\n          .domain([1, yd[1]])\n          .range([y0, y1])\n          .clamp(true)\n        : d3.scale.linear()\n          .domain([0, yd[1]])\n          .range([y0, y1]);\n      y.nice();\n\n      var x = d3.scale.linear()\n        .domain(d3.extent(data, dx))\n        .range([margin.left, width - margin.right]);\n\n      var yAxis = d3.svg.axis()\n        .orient('left')\n        .scale(y);\n\n      var si = d3.format('s');\n      var suffix = {K: 'k', M: 'm', G: 'b'};\n      var ticks = 3;\n      var yFormat = function(n, i) {\n        var p = (i === 0 || i === ticks) ? '$' : '';\n        return p + si(n).replace(/[KMG]$/, function(s) {\n          return suffix[s] || s;\n        });\n      };\n\n      if (log) {\n        ticks -= 1;\n        yAxis.ticks(ticks, yFormat);\n      } else {\n        yAxis.ticks(ticks)\n          .tickFormat(yFormat);\n      }\n\n      svg.append('g')\n        .attr('class', 'axis y')\n        .attr('transform', 'translate(' + [margin.left - axisSpacing, 0] + ')')\n        .call(yAxis);\n\n      svg.append('g')\n        .attr('class', 'axis x')\n        .attr('transform', 'translate(' + [0, height - margin.bottom + axisSpacing] + ')')\n        .call(d3.svg.axis()\n          .orient('bottom')\n          .scale(x)\n          .tickFormat(d3.format('d')));\n\n      var stack = d3.layout.stack();\n\n      var g = svg.selectAll('g.layer')\n        .data(stack(layers))\n        .enter()\n        .append('g')\n          .attr('class', 'layer')\n          .append('a');\n\n      var area = d3.svg.area()\n        .interpolate(interpolate)\n        .x(function(d) { return x(d.x); });\n\n      if (stacked) {\n        area\n          .y0(function(d) { return y(d.y0); })\n          .y1(function(d) { return y(d.y + d.y0); });\n      } else {\n        area\n          .y0(y(0))\n          .y1(function(d) { return y(d.y); });\n      }\n\n      var paths = g.append('path')\n        .attr('fill', function(d) {\n          return fill(d.key);\n        })\n        .attr('d', area);\n\n      if (voronoi) {\n        var points = [];\n        paths.each(function(d) {\n          d.forEach(function(v) {\n            points.push({\n              data: d,\n              value: v,\n              x: x(v.x),\n              y: y(v.y)\n            });\n          });\n        });\n\n        var vor = eiti.charts.voronoi()\n          .points(points)\n          .clipExtent([\n            [margin.left - axisSpacing, margin.top],\n            [width - margin.right + axisSpacing, height - margin.bottom + axisSpacing]\n          ]);\n\n        var regions = svg.append('g')\n          .attr('class', 'voronoi')\n          .call(vor)\n          .selectAll('*')\n            // NB: you have to do this to revert the data \"back\"\n            // to its pre-voronoi() state\n            .datum(function(d) {\n              return d.point.value;\n            });\n      }\n    };\n\n    /**\n     * Get or set the chart's margin in pixels.\n     *\n     * @example\n     * var margin = areaChart.margin();\n     * areaChart.margin({top: 0, right: 20, bottom: 30, left: 10});\n     * areaChart.margin([0, 100]); // NB: [y, x]\n     * areaChart.margin(20); // 20 on all sides\n     *\n     * @param {*=} margin set the margin as returned by {@link eiti.ui.margin}.\n     */\n    areaChart.margin = function(_) {\n      if (!arguments.length) return margin;\n      margin = eiti.ui.margin(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's horizontal value accessor.\n     *\n     * @example\n     * var x = areaChart.x();\n     * areaChart.x(function(d) { return d.Year; });\n     * areaChart.x('Year'); // same as above\n     *\n     * @param {String|Function=} x set the horizontal value accessor\n     */\n    areaChart.x = function(_) {\n      if (!arguments.length) return dx;\n      dx = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's *layer group* accessor.\n     *\n     * @example\n     * var y = areaChart.y();\n     * areaChart.y(function(d) { return d.Commodity; });\n     * areaChart.y('Commodity'); // same as above\n     *\n     * @param {String|Function=} y set the layer group accessor\n     */\n    areaChart.y = function(_) {\n      if (!arguments.length) return dy;\n      dy = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's vertical (numeric) value accessor.\n     *\n     * @example\n     * var value = areaChart.value();\n     * areaChart.value(function(d) { return d.Revenue; });\n     * areaChart.value('Revenue'); // same as above\n     *\n     * @param {String|Function=} v set the vertical value accessor\n     */\n    areaChart.value = function(_) {\n      if (!arguments.length) return value;\n      value = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle stacking layout. Area charts are not stacked by\n     * default.\n     *\n     * @example\n     * var stacked = areaChart.stacked();\n     * areaChart.stacked(true); // tell it to stack\n     *\n     * @param {Boolean=} stacked if `true`, enabled stacking layout\n     */\n    areaChart.stacked = function(_) {\n      if (!arguments.length) return stacked;\n      stacked = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Toggle logarithmic y-axis scaling.\n     *\n     * @example\n     * var log = areaChart.log();\n     * areaChart.log(true); // use logarithmic scaling\n     *\n     * @param {Boolean=} log if `true`, enabled logarithmic scaling\n     */\n    areaChart.log = function(_) {\n      if (!arguments.length) return log;\n      log = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Get or set the layer fill accessor.\n     *\n     * @example\n     * var fill = areaChart.fill();\n     * areaChart.fill(d3.scale.category20());\n     * areaChart.fill(function(d, i) {\n     *   return i % 2 ? 'yellow' : 'orange';\n     * });\n     * areaChart.fill('red');\n     *\n     * @param {*=} fill set the fill accessor\n     */\n    areaChart.fill = function(_) {\n      if (!arguments.length) return fill;\n      fill = d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle creation of Voronoi regions for interactivity.\n     *\n     * @param {Boolean=} voronoi if `true`, voronoi regions will be created\n     */\n    areaChart.voronoi = function(_) {\n      if (!arguments.length) return voronoi;\n      voronoi = _;\n      return areaChart;\n    };\n\n    return areaChart;\n  }"
          },
          "examples": [
            "<span class=\"hljs-keyword\">var</span> log = areaChart.log();\nareaChart.log(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// use logarithmic scaling</span>"
          ],
          "params": [
            {
              "title": "param",
              "description": "if `true`, enabled logarithmic scaling",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "NameExpression",
                  "name": "Boolean"
                }
              },
              "name": "log"
            }
          ],
          "name": "log",
          "kind": "function",
          "memberof": "areaChart",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "areaChart",
            "log"
          ]
        },
        {
          "description": "Get or set the layer fill accessor.",
          "tags": [
            {
              "title": "example",
              "description": "var fill = areaChart.fill();\nareaChart.fill(d3.scale.category20());\nareaChart.fill(function(d, i) {\n  return i % 2 ? 'yellow' : 'orange';\n});\nareaChart.fill('red');"
            },
            {
              "title": "param",
              "description": "set the fill accessor",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "AllLiteral"
                }
              },
              "name": "fill"
            },
            {
              "title": "name",
              "name": "fill"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "areaChart"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 335,
                "column": 4
              },
              "end": {
                "line": 339,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.charts.js",
            "code": "{\n    var dx = getter('Year');\n    var dy = getter('Commodity');\n    var value = getter('Revenue');\n    var stacked = false;\n    var log = false;\n\n    var width = 960;\n    var height = 100;\n\n    var margin = {\n      top: 10,\n      bottom: 25,\n      left: 50,\n      right: 20\n    };\n\n    var axisSpacing = 5;\n\n    var fill = d3.scale.category10();\n    var interpolate = 'cardinal';\n\n    var voronoi = false;\n\n    /**\n     * Renders a chart in a given d3 selection. Use {@link\n     * eiti.charts.area} to create one.\n     *\n     * @namespace areaChart\n     * @param {d3.selection} svg  a d3 `<svg>` element selection\n     * @param {Array=} data optional data\n     */\n    var areaChart = function(svg, data) {\n      if (data) {\n        svg.datum(data);\n      } else {\n        data = svg.datum() || [];\n      }\n      svg.attr('viewBox', [0, 0, width, height].join(' '));\n\n      var index = d3.nest()\n        .key(dy)\n        .key(dx)\n        .rollup(function(d) {\n          return d3.sum(d, value);\n        })\n        .map(data);\n\n      var xs = d3.extent(data, dx).map(Number);\n      var ys = d3.keys(index);\n      var xd = d3.range(xs[0], xs[1] + 1);\n      var layers = ys.map(function(y) {\n        return xd.map(function(x) {\n          var z = index[y][x] || 0;\n          if (stacked && z < 0) z = 0;\n          return {\n            x: x,\n            y: z,\n            key: y\n          };\n        });\n      });\n\n      layers.forEach(function(d) {\n        d.key = d[0].key;\n        d.sum = d3.sum(d, getter('y'));\n      });\n\n      layers.sort(function(a, b) {\n        return d3.descending(a.sum, b.sum);\n      });\n\n      var aggr = stacked ? d3.sum : d3.max;\n      var yd = d3.extent(xd, function(x, i) {\n        return aggr(layers, function(d) {\n          return d[i].y;\n        });\n      });\n\n      var y0 = height - margin.bottom;\n      var y1 = margin.top;\n\n      var y = log\n        ? d3.scale.log()\n          .domain([1, yd[1]])\n          .range([y0, y1])\n          .clamp(true)\n        : d3.scale.linear()\n          .domain([0, yd[1]])\n          .range([y0, y1]);\n      y.nice();\n\n      var x = d3.scale.linear()\n        .domain(d3.extent(data, dx))\n        .range([margin.left, width - margin.right]);\n\n      var yAxis = d3.svg.axis()\n        .orient('left')\n        .scale(y);\n\n      var si = d3.format('s');\n      var suffix = {K: 'k', M: 'm', G: 'b'};\n      var ticks = 3;\n      var yFormat = function(n, i) {\n        var p = (i === 0 || i === ticks) ? '$' : '';\n        return p + si(n).replace(/[KMG]$/, function(s) {\n          return suffix[s] || s;\n        });\n      };\n\n      if (log) {\n        ticks -= 1;\n        yAxis.ticks(ticks, yFormat);\n      } else {\n        yAxis.ticks(ticks)\n          .tickFormat(yFormat);\n      }\n\n      svg.append('g')\n        .attr('class', 'axis y')\n        .attr('transform', 'translate(' + [margin.left - axisSpacing, 0] + ')')\n        .call(yAxis);\n\n      svg.append('g')\n        .attr('class', 'axis x')\n        .attr('transform', 'translate(' + [0, height - margin.bottom + axisSpacing] + ')')\n        .call(d3.svg.axis()\n          .orient('bottom')\n          .scale(x)\n          .tickFormat(d3.format('d')));\n\n      var stack = d3.layout.stack();\n\n      var g = svg.selectAll('g.layer')\n        .data(stack(layers))\n        .enter()\n        .append('g')\n          .attr('class', 'layer')\n          .append('a');\n\n      var area = d3.svg.area()\n        .interpolate(interpolate)\n        .x(function(d) { return x(d.x); });\n\n      if (stacked) {\n        area\n          .y0(function(d) { return y(d.y0); })\n          .y1(function(d) { return y(d.y + d.y0); });\n      } else {\n        area\n          .y0(y(0))\n          .y1(function(d) { return y(d.y); });\n      }\n\n      var paths = g.append('path')\n        .attr('fill', function(d) {\n          return fill(d.key);\n        })\n        .attr('d', area);\n\n      if (voronoi) {\n        var points = [];\n        paths.each(function(d) {\n          d.forEach(function(v) {\n            points.push({\n              data: d,\n              value: v,\n              x: x(v.x),\n              y: y(v.y)\n            });\n          });\n        });\n\n        var vor = eiti.charts.voronoi()\n          .points(points)\n          .clipExtent([\n            [margin.left - axisSpacing, margin.top],\n            [width - margin.right + axisSpacing, height - margin.bottom + axisSpacing]\n          ]);\n\n        var regions = svg.append('g')\n          .attr('class', 'voronoi')\n          .call(vor)\n          .selectAll('*')\n            // NB: you have to do this to revert the data \"back\"\n            // to its pre-voronoi() state\n            .datum(function(d) {\n              return d.point.value;\n            });\n      }\n    };\n\n    /**\n     * Get or set the chart's margin in pixels.\n     *\n     * @example\n     * var margin = areaChart.margin();\n     * areaChart.margin({top: 0, right: 20, bottom: 30, left: 10});\n     * areaChart.margin([0, 100]); // NB: [y, x]\n     * areaChart.margin(20); // 20 on all sides\n     *\n     * @param {*=} margin set the margin as returned by {@link eiti.ui.margin}.\n     */\n    areaChart.margin = function(_) {\n      if (!arguments.length) return margin;\n      margin = eiti.ui.margin(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's horizontal value accessor.\n     *\n     * @example\n     * var x = areaChart.x();\n     * areaChart.x(function(d) { return d.Year; });\n     * areaChart.x('Year'); // same as above\n     *\n     * @param {String|Function=} x set the horizontal value accessor\n     */\n    areaChart.x = function(_) {\n      if (!arguments.length) return dx;\n      dx = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's *layer group* accessor.\n     *\n     * @example\n     * var y = areaChart.y();\n     * areaChart.y(function(d) { return d.Commodity; });\n     * areaChart.y('Commodity'); // same as above\n     *\n     * @param {String|Function=} y set the layer group accessor\n     */\n    areaChart.y = function(_) {\n      if (!arguments.length) return dy;\n      dy = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Get or set the chart's vertical (numeric) value accessor.\n     *\n     * @example\n     * var value = areaChart.value();\n     * areaChart.value(function(d) { return d.Revenue; });\n     * areaChart.value('Revenue'); // same as above\n     *\n     * @param {String|Function=} v set the vertical value accessor\n     */\n    areaChart.value = function(_) {\n      if (!arguments.length) return value;\n      value = (typeof _ === 'string')\n        ? getter(_)\n        : d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle stacking layout. Area charts are not stacked by\n     * default.\n     *\n     * @example\n     * var stacked = areaChart.stacked();\n     * areaChart.stacked(true); // tell it to stack\n     *\n     * @param {Boolean=} stacked if `true`, enabled stacking layout\n     */\n    areaChart.stacked = function(_) {\n      if (!arguments.length) return stacked;\n      stacked = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Toggle logarithmic y-axis scaling.\n     *\n     * @example\n     * var log = areaChart.log();\n     * areaChart.log(true); // use logarithmic scaling\n     *\n     * @param {Boolean=} log if `true`, enabled logarithmic scaling\n     */\n    areaChart.log = function(_) {\n      if (!arguments.length) return log;\n      log = !!_;\n      return areaChart;\n    };\n\n    /**\n     * Get or set the layer fill accessor.\n     *\n     * @example\n     * var fill = areaChart.fill();\n     * areaChart.fill(d3.scale.category20());\n     * areaChart.fill(function(d, i) {\n     *   return i % 2 ? 'yellow' : 'orange';\n     * });\n     * areaChart.fill('red');\n     *\n     * @param {*=} fill set the fill accessor\n     */\n    areaChart.fill = function(_) {\n      if (!arguments.length) return fill;\n      fill = d3.functor(_);\n      return areaChart;\n    };\n\n    /**\n     * Toggle creation of Voronoi regions for interactivity.\n     *\n     * @param {Boolean=} voronoi if `true`, voronoi regions will be created\n     */\n    areaChart.voronoi = function(_) {\n      if (!arguments.length) return voronoi;\n      voronoi = _;\n      return areaChart;\n    };\n\n    return areaChart;\n  }"
          },
          "examples": [
            "<span class=\"hljs-keyword\">var</span> fill = areaChart.fill();\nareaChart.fill(d3.scale.category20());\nareaChart.fill(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(d, i)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> i % <span class=\"hljs-number\">2</span> ? <span class=\"hljs-string\">'yellow'</span> : <span class=\"hljs-string\">'orange'</span>;\n});\nareaChart.fill(<span class=\"hljs-string\">'red'</span>);"
          ],
          "params": [
            {
              "title": "param",
              "description": "set the fill accessor",
              "type": {
                "type": "OptionalType",
                "expression": {
                  "type": "AllLiteral"
                }
              },
              "name": "fill"
            }
          ],
          "name": "fill",
          "kind": "function",
          "memberof": "areaChart",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "areaChart",
            "fill"
          ]
        }
      ]
    },
    "path": [
      "areaChart"
    ]
  },
  {
    "description": "Commodity grouping and color model.",
    "tags": [
      {
        "title": "class",
        "description": null,
        "type": null,
        "name": null
      },
      {
        "title": "name",
        "name": "Commodities"
      },
      {
        "title": "kind",
        "kind": "class"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 90,
          "column": 4
        },
        "end": {
          "line": 113,
          "column": 6
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  }"
    },
    "name": "Commodities",
    "kind": "class",
    "members": {
      "instance": [
        {
          "description": "Get the list of commodity groups as an array.",
          "tags": [
            {
              "title": "function",
              "description": null,
              "name": null
            },
            {
              "title": "returns",
              "description": null,
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  }
                ]
              }
            },
            {
              "title": "name",
              "name": "getGroups"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "Commodities"
            },
            {
              "title": "instance"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 148,
                "column": 4
              },
              "end": {
                "line": 150,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.js",
            "code": "{\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  }"
          },
          "returns": [
            {
              "title": "returns",
              "description": null,
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  }
                ]
              }
            }
          ],
          "name": "getGroups",
          "kind": "function",
          "memberof": "Commodities",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Commodities",
            "getGroups"
          ]
        },
        {
          "description": "Get the nesting group for a given commodity.",
          "tags": [
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "commodity"
            },
            {
              "title": "returns",
              "description": "the commodity group",
              "type": {
                "type": "NameExpression",
                "name": "String"
              }
            },
            {
              "title": "name",
              "name": "getGroup"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "Commodities"
            },
            {
              "title": "instance"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 126,
                "column": 4
              },
              "end": {
                "line": 130,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.js",
            "code": "{\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  }"
          },
          "params": [
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "commodity"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "the commodity group",
              "type": {
                "type": "NameExpression",
                "name": "String"
              }
            }
          ],
          "name": "getGroup",
          "kind": "function",
          "memberof": "Commodities",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Commodities",
            "getGroup"
          ]
        },
        {
          "description": "Get the primary color for a commodity group.",
          "tags": [
            {
              "title": "param",
              "description": "the commodity or group",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "commodity"
            },
            {
              "title": "returns",
              "description": "a CSS color",
              "type": {
                "type": "NameExpression",
                "name": "String"
              }
            },
            {
              "title": "name",
              "name": "getPrimaryColor"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "Commodities"
            },
            {
              "title": "instance"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 172,
                "column": 4
              },
              "end": {
                "line": 174,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.js",
            "code": "{\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  }"
          },
          "params": [
            {
              "title": "param",
              "description": "the commodity or group",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "commodity"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "a CSS color",
              "type": {
                "type": "NameExpression",
                "name": "String"
              }
            }
          ],
          "name": "getPrimaryColor",
          "kind": "function",
          "memberof": "Commodities",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Commodities",
            "getPrimaryColor"
          ]
        },
        {
          "description": "Get the colors associated with a commodity's group color\nscheme.",
          "tags": [
            {
              "title": "param",
              "description": "the commodity or group",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "commodity"
            },
            {
              "title": "param",
              "description": "the number of color steps (default: 9)",
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "steps"
            },
            {
              "title": "returns",
              "description": null,
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  }
                ]
              }
            },
            {
              "title": "name",
              "name": "getColors"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "Commodities"
            },
            {
              "title": "instance"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 159,
                "column": 4
              },
              "end": {
                "line": 165,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.js",
            "code": "{\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  }"
          },
          "params": [
            {
              "title": "param",
              "description": "the commodity or group",
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "commodity"
            },
            {
              "title": "param",
              "description": "the number of color steps (default: 9)",
              "type": {
                "type": "NameExpression",
                "name": "Number"
              },
              "name": "steps"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": null,
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "String"
                  }
                ]
              }
            }
          ],
          "name": "getColors",
          "kind": "function",
          "memberof": "Commodities",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Commodities",
            "getColors"
          ]
        },
        {
          "description": "Set the nesting group for a given commodity.",
          "tags": [
            {
              "title": "function",
              "description": null,
              "name": null
            },
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "commodity"
            },
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "group"
            },
            {
              "title": "name",
              "name": "setGroup"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "Commodities"
            },
            {
              "title": "instance"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 138,
                "column": 4
              },
              "end": {
                "line": 141,
                "column": 6
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.js",
            "code": "{\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  }"
          },
          "params": [
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "commodity"
            },
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "String"
              },
              "name": "group"
            }
          ],
          "name": "setGroup",
          "kind": "function",
          "memberof": "Commodities",
          "scope": "instance",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Commodities",
            "setGroup"
          ]
        }
      ],
      "static": [
        {
          "description": "The group to which commodities with an unspecified group will\nbe assigned, namely `Other Commodities`.",
          "tags": [
            {
              "title": "name",
              "name": "OTHER"
            },
            {
              "title": "memberof",
              "description": "Commodities"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 119,
                "column": 4
              },
              "end": {
                "line": 119,
                "column": 44
              }
            },
            "file": "/Users/allens/work/eiti-data/js/eiti.js",
            "code": "{\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  }"
          },
          "name": "OTHER",
          "memberof": "Commodities",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Commodities",
            "OTHER"
          ]
        }
      ]
    },
    "path": [
      "Commodities"
    ]
  },
  {
    "description": "Produces short dollar strings in SI format with 1 decimal,\ne.g. `$1.2m` or `$4.8b`.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.format.shortDollars"
      },
      {
        "title": "function",
        "description": null,
        "name": null
      },
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Number"
        },
        "name": "num"
      },
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.format"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 741,
          "column": 2
        },
        "end": {
          "line": 746,
          "column": 5
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.format.shortDollars",
    "params": [
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Number"
        },
        "name": "num"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "kind": "function",
    "memberof": "eiti.format",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.format.shortDollars"
    ]
  },
  {
    "description": "Produces dollar strings with thousands separators and 2-decimal\ncents, e.g. `$1,234,567.89`.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.format.dollarsAndCents"
      },
      {
        "title": "function",
        "description": null,
        "name": null
      },
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Number"
        },
        "name": "num"
      },
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.format"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 731,
          "column": 2
        },
        "end": {
          "line": 731,
          "column": 51
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.format.dollarsAndCents",
    "params": [
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Number"
        },
        "name": "num"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "kind": "function",
    "memberof": "eiti.format",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.format.dollarsAndCents"
    ]
  },
  {
    "description": "Produces whole dollar strings with thousands separators, e.g.\n`$1,234,567`.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.format.dollars"
      },
      {
        "title": "function",
        "description": null,
        "name": null
      },
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Number"
        },
        "name": "num"
      },
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.format"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 721,
          "column": 2
        },
        "end": {
          "line": 721,
          "column": 43
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.format.dollars",
    "params": [
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Number"
        },
        "name": "num"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "kind": "function",
    "memberof": "eiti.format",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.format.dollars"
    ]
  },
  {
    "description": "Nest data into an object structure:",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.data.nest"
      },
      {
        "title": "example",
        "description": "var data = [{x: 1, y: 2}, {x: 2, y: 2}];\nvar nested = eiti.data.nest(data, ['x', 'y']);\nassert.deepEqual(nested, {\n  1: {\n    2: [\n      {x: 1, y: 2}\n    ]\n  },\n  2: {\n    2: [\n      {x: 2, y: 2}\n    ]\n  }\n});"
      },
      {
        "title": "param",
        "description": "a dimensional tabular data set",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "rows"
      },
      {
        "title": "param",
        "description": "a list of key functions or property names",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "keys"
      },
      {
        "title": "param",
        "description": "an optional value rollup function",
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "Function"
          }
        },
        "name": "rollup"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.data"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 37,
          "column": 2
        },
        "end": {
          "line": 44,
          "column": 4
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.data.nest",
    "examples": [
      "<span class=\"hljs-keyword\">var</span> data = [{x: <span class=\"hljs-number\">1</span>, y: <span class=\"hljs-number\">2</span>}, {x: <span class=\"hljs-number\">2</span>, y: <span class=\"hljs-number\">2</span>}];\n<span class=\"hljs-keyword\">var</span> nested = eiti.data.nest(data, [<span class=\"hljs-string\">'x'</span>, <span class=\"hljs-string\">'y'</span>]);\nassert.deepEqual(nested, {\n  <span class=\"hljs-number\">1</span>: {\n    <span class=\"hljs-number\">2</span>: [\n      {x: <span class=\"hljs-number\">1</span>, y: <span class=\"hljs-number\">2</span>}\n    ]\n  },\n  <span class=\"hljs-number\">2</span>: {\n    <span class=\"hljs-number\">2</span>: [\n      {x: <span class=\"hljs-number\">2</span>, y: <span class=\"hljs-number\">2</span>}\n    ]\n  }\n});"
    ],
    "params": [
      {
        "title": "param",
        "description": "a dimensional tabular data set",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "rows"
      },
      {
        "title": "param",
        "description": "a list of key functions or property names",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "keys"
      },
      {
        "title": "param",
        "description": "an optional value rollup function",
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "Function"
          }
        },
        "name": "rollup"
      }
    ],
    "kind": "function",
    "memberof": "eiti.data",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.data.nest"
    ]
  },
  {
    "description": "Walk a nested object structure and call a function on each\n\"leaf\" node (that is not an object).",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.data.walk"
      },
      {
        "title": "example",
        "description": "var value = [];\neiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n  values.push(d);\n});\nassert.deepEqual(values, ['baz']);"
      },
      {
        "title": "param",
        "description": "the array or object to iterate over",
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "Object"
            }
          ]
        },
        "name": "data"
      },
      {
        "title": "param",
        "description": "the function to call on each leaf node",
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "callback"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.data"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 66,
          "column": 2
        },
        "end": {
          "line": 82,
          "column": 4
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.data.walk",
    "examples": [
      "<span class=\"hljs-keyword\">var</span> value = [];\neiti.data.walk({foo: {bar: <span class=\"hljs-string\">'baz'</span>}}, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(d, i)</span> </span>{\n  values.push(d);\n});\nassert.deepEqual(values, [<span class=\"hljs-string\">'baz'</span>]);"
    ],
    "params": [
      {
        "title": "param",
        "description": "the array or object to iterate over",
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "Array"
            },
            {
              "type": "NameExpression",
              "name": "Object"
            }
          ]
        },
        "name": "data"
      },
      {
        "title": "param",
        "description": "the function to call on each leaf node",
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "callback"
      }
    ],
    "kind": "function",
    "memberof": "eiti.data",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.data.walk"
    ]
  },
  {
    "description": "Produces international system/metric form, e.g. `4.1M`",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.format.metric"
      },
      {
        "title": "function",
        "description": null,
        "name": null
      },
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Number"
        },
        "name": "num"
      },
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.format"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 711,
          "column": 2
        },
        "end": {
          "line": 711,
          "column": 40
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.format.metric",
    "params": [
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Number"
        },
        "name": "num"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "String"
        }
      }
    ],
    "kind": "function",
    "memberof": "eiti.format",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.format.metric"
    ]
  },
  {
    "description": "Create a range formatter that strips the preceding `$`\nfrom the second value to produce strings like `$10m - 20m`\ninstead of `$10m - $20m`.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.format.range"
      },
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Function"
            }
          ]
        },
        "name": "format"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.format"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 680,
          "column": 2
        },
        "end": {
          "line": 702,
          "column": 4
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.format.range",
    "params": [
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Function"
            }
          ]
        },
        "name": "format"
      }
    ],
    "kind": "function",
    "memberof": "eiti.format",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.format.range"
    ]
  },
  {
    "description": "Create a key getter function a la Python's\nitertools.itemgetter().",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.data.getter"
      },
      {
        "title": "example",
        "description": "var title = eiti.data.getter('title');\nvar titles = data.map(title);"
      },
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Number"
            },
            {
              "type": "NameExpression",
              "name": "Function"
            }
          ]
        },
        "name": "key"
      },
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        }
      },
      {
        "title": "memberof",
        "description": "eiti.data"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 300,
          "column": 2
        },
        "end": {
          "line": 300,
          "column": 28
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.data.getter",
    "examples": [
      "<span class=\"hljs-keyword\">var</span> title = eiti.data.getter(<span class=\"hljs-string\">'title'</span>);\n<span class=\"hljs-keyword\">var</span> titles = data.map(title);"
    ],
    "params": [
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Number"
            },
            {
              "type": "NameExpression",
              "name": "Function"
            }
          ]
        },
        "name": "key"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        }
      }
    ],
    "memberof": "eiti.data",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.data.getter"
    ]
  },
  {
    "description": "Create a slider from a d3 selection that dispatches 'change'\nevents whenever the element is clicked, tapped or dragged.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.ui.slider"
      },
      {
        "title": "example",
        "description": "var slider = eiti.ui.slider()\n   .range([0, 100])\n   .on('change', function(e) {\n     console.log('slider value:', e.value);\n   });\n d3.select('#slider')\n   .call(slider);"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.ui"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 378,
          "column": 2
        },
        "end": {
          "line": 546,
          "column": 4
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.ui.slider",
    "examples": [
      "<span class=\"hljs-keyword\">var</span> slider = eiti.ui.slider()\n   .range([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>])\n   .on(<span class=\"hljs-string\">'change'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(e)</span> </span>{\n     <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'slider value:'</span>, e.value);\n   });\n d3.select(<span class=\"hljs-string\">'#slider'</span>)\n   .call(slider);"
    ],
    "kind": "function",
    "memberof": "eiti.ui",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.ui.slider"
    ]
  },
  {
    "description": "Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\ninstance with \"show\" and \"hide\" event dispatching capabilities.\nEITI tips also have a `.target()` accessor which allows you to\noverride the element that's used to calculate tooltip\npositioning.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.ui.tip"
      },
      {
        "title": "example",
        "description": "var tip = eiti.ui.tip()\n  .on('show', function() {\n    console.log('tip show:', this);\n  })\n  .target(function() {\n    return this.querySelector('circle');\n  });"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.ui"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 322,
          "column": 2
        },
        "end": {
          "line": 361,
          "column": 4
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.ui.tip",
    "examples": [
      "<span class=\"hljs-keyword\">var</span> tip = eiti.ui.tip()\n  .on(<span class=\"hljs-string\">'show'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'tip show:'</span>, <span class=\"hljs-keyword\">this</span>);\n  })\n  .target(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.querySelector(<span class=\"hljs-string\">'circle'</span>);\n  });"
    ],
    "kind": "function",
    "memberof": "eiti.ui",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.ui.tip"
    ]
  },
  {
    "description": "Create a margin object {top, right, left, bottom} from any \nof the following types:\n\n- string: coerce to a number\n- number: a margin object with equal top, right, left and\n  bottom values\n- array: read the values as [top, right, bottom, left] if there\n  are 4 or more elements; otherwise read as [vertical,\n  horizontal]\n- object: set top, right, bottom and left keys to 0 if not set,\n  then return the object",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.ui.margin"
      },
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "AllLiteral"
        },
        "name": "input"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.ui"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 564,
          "column": 2
        },
        "end": {
          "line": 582,
          "column": 4
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.ui.margin",
    "params": [
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "AllLiteral"
        },
        "name": "input"
      }
    ],
    "kind": "function",
    "memberof": "eiti.ui",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.ui.margin"
    ]
  },
  {
    "description": "Extend objects with additional properties, a la `$.extend()`.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.util.extend"
      },
      {
        "title": "param",
        "description": "the base object onto which all other\n                       properties will be added",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "base"
      },
      {
        "title": "param",
        "description": "one or more additional objects with\n                       properties to be copied",
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "Object"
          }
        },
        "name": "other"
      },
      {
        "title": "returns",
        "description": "the `base` object with added properties",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        }
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.util"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 596,
          "column": 2
        },
        "end": {
          "line": 603,
          "column": 4
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.util.extend",
    "params": [
      {
        "title": "param",
        "description": "the base object onto which all other\n                       properties will be added",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "base"
      },
      {
        "title": "param",
        "description": "one or more additional objects with\n                       properties to be copied",
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "Object"
          }
        },
        "name": "other"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "the `base` object with added properties",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        }
      }
    ],
    "kind": "function",
    "memberof": "eiti.util",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.util.extend"
    ]
  },
  {
    "description": "Force a reset of location.hash so that the browser (hopefully)\nscrolls to the element with the fragment identifier and toggles\nthe :target pseudo-class.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.util.jiggleHash"
      },
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Boolean"
        }
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.util"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 613,
          "column": 2
        },
        "end": {
          "line": 621,
          "column": 4
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.util.jiggleHash",
    "returns": [
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Boolean"
        }
      }
    ],
    "kind": "function",
    "memberof": "eiti.util",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.util.jiggleHash"
    ]
  },
  {
    "description": "d3 helper for bringing an element to the front among its\nsiblings. Use it with an event listener, e.g.:",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.util.bringToFront"
      },
      {
        "title": "example",
        "description": "d3.selectAll('svg path')\n  .on('mouseover', eiti.util.bringToFront);"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.util"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 632,
          "column": 2
        },
        "end": {
          "line": 635,
          "column": 4
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.util.bringToFront",
    "examples": [
      "d3.selectAll(<span class=\"hljs-string\">'svg path'</span>)\n  .on(<span class=\"hljs-string\">'mouseover'</span>, eiti.util.bringToFront);"
    ],
    "kind": "function",
    "memberof": "eiti.util",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.util.bringToFront"
    ]
  },
  {
    "description": "The compliment to {@link bringToFront}, returns an\nelement to its previous position among its siblings.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.util.sendToBack"
      },
      {
        "title": "example",
        "description": "d3.selectAll('svg path')\n  .on('mouseover', eiti.util.bringToFront)\n  .on('mouseout', eiti.util.sendToBack);"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.util"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 647,
          "column": 2
        },
        "end": {
          "line": 650,
          "column": 4
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.util.sendToBack",
    "examples": [
      "d3.selectAll(<span class=\"hljs-string\">'svg path'</span>)\n  .on(<span class=\"hljs-string\">'mouseover'</span>, eiti.util.bringToFront)\n  .on(<span class=\"hljs-string\">'mouseout'</span>, eiti.util.sendToBack);"
    ],
    "kind": "function",
    "memberof": "eiti.util",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.util.sendToBack"
    ]
  },
  {
    "description": "Create a composite format that wraps a d3 format (or any other\nformatting function) with a transform function.",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "eiti.format.transform"
      },
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Function"
            }
          ]
        },
        "name": "format"
      },
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "transform"
      },
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        }
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "eiti.format"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 662,
          "column": 2
        },
        "end": {
          "line": 669,
          "column": 4
        }
      },
      "file": "/Users/allens/work/eiti-data/js/eiti.js",
      "code": "{\n\n  /*\n   * @namespace eiti\n   */\n  var eiti = exports.eiti = {};\n\n  /*\n   * data classes and functions\n   */\n  eiti.data = {};\n\n  /**\n   * Nest data into an object structure:\n   * @name eiti.data.nest\n   *\n   * @example\n   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];\n   * var nested = eiti.data.nest(data, ['x', 'y']);\n   * assert.deepEqual(nested, {\n   *   1: {\n   *     2: [\n   *       {x: 1, y: 2}\n   *     ]\n   *   },\n   *   2: {\n   *     2: [\n   *       {x: 2, y: 2}\n   *     ]\n   *   }\n   * });\n   *\n   * @param {Array} rows a dimensional tabular data set\n   * @param {Array} keys a list of key functions or property names\n   * @param {Function=} rollup an optional value rollup function\n   */\n  eiti.data.nest = function(rows, keys, rollup) {\n    var nest = d3.nest();\n    keys.forEach(function(k) {\n      nest.key(getter(k));\n    });\n    if (rollup) nest.rollup(rollup);\n    return nest.map(rows);\n  };\n\n  function isScalar(d) {\n    return typeof d !== 'object';\n  }\n\n  /**\n   * Walk a nested object structure and call a function on each\n   * \"leaf\" node (that is not an object).\n   * @name eiti.data.walk\n   *\n   * @example\n   * var value = [];\n   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {\n   *   values.push(d);\n   * });\n   * assert.deepEqual(values, ['baz']);\n   *\n   * @param {Array|Object} data the array or object to iterate over\n   * @param {Function} callback the function to call on each leaf node\n   * @return void\n   */\n  eiti.data.walk = function(struct, each) {\n    walk(struct);\n\n    function walk(d, i) {\n      if (Array.isArray(d)) {\n        return d.forEach(function(v, i) {\n          walk.call(d, v, i);\n        });\n      } else if (typeof d === 'object') {\n        return d3.keys(d).forEach(function(key) {\n          walk.call(d, d[key], key);\n        });\n      } else {\n        each.call(this, d, i);\n      }\n    }\n  };\n\n  eiti.data.Commodities = (function() {\n\n    /**\n     * Commodity grouping and color model.\n     * @class\n     */\n    var Commodities = function() {\n      if (!(this instanceof Commodities)) return new Commodities();\n      this.groups = d3.set([\n        'Coal',\n        'Gas',\n        'Geothermal',\n        'Oil',\n        'Oil & Gas',\n        Commodities.OTHER\n      ]);\n\n      this.groupMap = {\n        'Oil Shale': 'Oil'\n      };\n\n      this.groupColors = {\n        'Coal': 'YlOrBr',\n        'Oil': 'Greys',\n        'Gas': 'Purples',\n        'Oil & Gas': 'RdPu',\n        'Geothermal': 'OrRd',\n        'Other Commodities': 'Blues'\n      };\n    };\n\n    /**\n     * The group to which commodities with an unspecified group will\n     * be assigned, namely `Other Commodities`.\n     */\n    Commodities.OTHER = 'Other Commodities';\n\n    /**\n     * Get the nesting group for a given commodity.\n     * @param {String} commodity\n     * @return {String} the commodity group\n     */\n    Commodities.prototype.getGroup = function(commodity) {\n      commodity = commodity.replace(/\\s\\([a-z]+\\)$/, '');\n      if (this.groups.has(commodity)) return commodity;\n      return this.groupMap[commodity] || Commodities.OTHER;\n    };\n\n    /**\n     * Set the nesting group for a given commodity.\n     * @method\n     * @param {String} commodity\n     * @param {String} group\n     */\n    Commodities.prototype.setGroup = function(commodity, group) {\n      this.groupMap[commodity] = group;\n      return this;\n    };\n\n    /**\n     * Get the list of commodity groups as an array.\n     * @method\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getGroups = function() {\n      return this.groups.values();\n    };\n\n    /**\n     * Get the colors associated with a commodity's group color\n     * scheme.\n     * @param {String} commodity the commodity or group\n     * @param {Number} steps the number of color steps (default: 9)\n     * @return {Array<String>}\n     */\n    Commodities.prototype.getColors = function(commodity, steps) {\n      if (!this.groups.has(commodity)) {\n        commodity = this.getGroup(commodity);\n      }\n      var scheme = this.groupColors[commodity] || 'Spectral';\n      return colorbrewer[scheme][steps || 9];\n    };\n\n    /**\n     * Get the primary color for a commodity group.\n     * @param {String} commodity the commodity or group\n     * @return {String} a CSS color\n     */\n    Commodities.prototype.getPrimaryColor = function(commodity) {\n      return this.getColors(commodity, 9)[4];\n    };\n\n    return Commodities;\n  })();\n\n  eiti.data.Model = (function() {\n\n    /**\n     * A data model for storing named datasets.\n     *\n     * @example\n     * var model = new eiti.data.Model();\n     *\n     * @class\n     * @alias eiti.data.Model\n     * @param {Object|d3.map} data optional datasets to initialize\n     */\n    var Model = function(data) {\n      if (!(this instanceof Model)) return new Model(data);\n      this.data = d3.map(data);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.has = function(name) {\n      return this.data.has(name);\n    };\n\n    /**\n     * @param {String} name the dataset name\n     * @return {Boolean} `true` if the named dataset exists, `false` if not\n     */\n    Model.prototype.get = function(name) {\n      return this.data.get(name);\n    };\n\n    /**\n     * Store a dataset with a unique key\n     * @param {String} name the dataset name\n     * @param {*} data the data to store\n     * @return {*} returns the data as set\n     */\n    Model.prototype.set = function(name, data) {\n      return this.data.set(name, data);\n    };\n\n    /**\n     * Load data from a URL into a named dataset.\n     *\n     * @example\n     * model.load('states', 'path/to/states.json', function(error, topology) {\n     * });\n     *\n     * @param {String} name the unique dataset name\n     * @param {String} url the URL to load\n     * @param {Function=} callback the callback function\n     */\n    Model.prototype.load = function(name, url, done) {\n      if (this.has(name)) {\n        return done(null, this.get(name));\n      }\n      var ext = url.split('.').pop();\n      var load = d3[ext || 'json'];\n      return load(url, function(error, data) {\n        if (error) return done(error);\n        this.set(name, data);\n        done && done(null, data);\n      }.bind(this));\n    };\n\n    /**\n     * Create a nested index using {@link eiti.data.nest} from a\n     * named dataset and alias it to a new name.\n     *\n     * @example\n     * model.set('foo', [\n     *   {x: 'bar', y: 'baz'},\n     *   {x: 'qux', y: 'quux'}\n     * ]);\n     * var index = model.createIndex('foo', 'bar', ['x', 'y']);\n     * assert.deepEqual(index, {\n     *   bar: {\n     *     baz: [\n     *       {x: 'bar', y: 'baz'}\n     *     ],\n     *   },\n     *   qux: {\n     *     quux: [\n     *       {x: 'qux', y: 'quux'}\n     *     ]\n     *   }\n     * });\n     *\n     * @param {String} src the source dataset name\n     * @param {String} dest the destination dataset name\n     * @param {Array<String|Function>} keys the keys to nest\n     * @param {Function=} rollup the optional rollup function\n     */\n    Model.prototype.createIndex = function(src, dest, keys, rollup) {\n      if (this.has(dest)) return this.get(dest);\n      var data = this.get(src);\n      var index = eiti.data.nest(data, keys, rollup);\n      return this.set(dest, index);\n    };\n\n    function getIndexKey(name, keys) {\n      return name + ':' + keys.join('/');\n    }\n\n    return Model;\n  })();\n\n  /**\n   * Create a key getter function a la Python's\n   * itertools.itemgetter().\n   * @name eiti.data.getter\n   *\n   * @example\n   * var title = eiti.data.getter('title');\n   * var titles = data.map(title);\n   *\n   * @param {String|Number|Function} key\n   * @return {Function}\n   */\n  eiti.data.getter = getter;\n\n  // UI bits\n  eiti.ui = {};\n\n  /**\n   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)\n   * instance with \"show\" and \"hide\" event dispatching capabilities.\n   * EITI tips also have a `.target()` accessor which allows you to\n   * override the element that's used to calculate tooltip\n   * positioning.\n   * @name eiti.ui.tip\n   *\n   * @example\n   * var tip = eiti.ui.tip()\n   *   .on('show', function() {\n   *     console.log('tip show:', this);\n   *   })\n   *   .target(function() {\n   *     return this.querySelector('circle');\n   *   });\n   */\n  eiti.ui.tip = function() {\n    var tip = d3.tip();\n    var show = tip.show;\n    var hide = tip.hide;\n    var dispatch = d3.dispatch('show', 'hide');\n\n    var target = null;\n\n    /*\n     * Override the target of the tooltip for positioning purposes.\n     * @example\n     * tip.target(function() {\n     *   return this.querySelector('circle');\n     * });\n     */\n    tip.target = function(_) {\n      if (!arguments.length) return target;\n      target = d3.functor(_);\n      return tip;\n    };\n\n    tip.show = function() {\n      var args = arguments;\n      if (dispatch.show.apply(this, arguments) !== false) {\n        if (target) {\n          var t = target ? target.apply(this, arguments) : null;\n          if (t) args = [].slice.call(args).concat([t]);\n        }\n        show.apply(this, args);\n      }\n    };\n\n    tip.hide = function() {\n      if (dispatch.hide.apply(this, arguments) !== false) {\n        hide.apply(this, arguments);\n      }\n    };\n\n    return d3.rebind(tip, dispatch, 'on');\n  };\n\n  /**\n   * Create a slider from a d3 selection that dispatches 'change'\n   * events whenever the element is clicked, tapped or dragged.\n   * @name eiti.ui.slider\n   *\n   * @example\n   *\n   *  var slider = eiti.ui.slider()\n   *    .range([0, 100])\n   *    .on('change', function(e) {\n   *      console.log('slider value:', e.value);\n   *    });\n   *  d3.select('#slider')\n   *    .call(slider);\n   */\n  eiti.ui.slider = function() {\n\n    var slider = function(selection) {\n      root = selection;\n      // XXX don't capture right-clicks (for inspecting)\n      selection.on('mousedown', function() {\n        var e = d3.event;\n        if (e.button === 2) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      });\n      selection.call(drag);\n      if (typeof value !== 'undefined') {\n        slider.update(root);\n      }\n    };\n\n    var root, value;\n    var dragging = false;\n\n    var nub = '.nub';\n    var scale = d3.scale.linear()\n      .clamp(true);\n\n    var snap = false;\n    var dispatch = d3.dispatch('change');\n    var format = String;\n\n    function drag(selection) {\n      selection.on('mousedown.slider', function() {\n        // console.log('[drag] down');\n        dragging = true;\n        var body = d3.select('body').on('mouseup.slider', function() {\n          // console.log('[drag] up');\n          dragging = false;\n          body.on('mouseup.slider', null);\n        });\n        move(d3.event);\n      })\n      .on('mousemove.slider', function() {\n        if (dragging) {\n          // console.log('[drag] move');\n          move(d3.event);\n          return false;\n        }\n      });\n    }\n\n    function move(e) {\n      var p = getPosition(e),\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(p.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      // console.log('[slider] drag:', [p.x, p.y].join(','), [w, x, u, v].join(' '));\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function getPosition(e) {\n      var p = e.type === 'touchstart'\n        ? d3.touches(root.node())[0]\n        : d3.mouse(root.node());\n      return {x: p[0], y: p[1]};\n    }\n\n    slider.nub = function(selector) {\n      if (!arguments.length) return nub;\n      nub = selector;\n      return slider;\n    };\n\n    slider.range = function(range) {\n      if (!arguments.length) return scale.range();\n      scale.range(range);\n      return slider;\n    };\n\n    slider.snap = function(x) {\n      if (!arguments.length) return snap;\n      snap = x;\n      var range = scale.range();\n      if (snap) {\n        scale.rangeRound(range);\n      } else {\n        scale.range(range);\n      }\n      return slider;\n    };\n\n    slider.value = function(x) {\n      if (!arguments.length) return value;\n      value = +x;\n      if (root && !dragging) {\n        slider.update(root);\n      }\n      return slider;\n    };\n\n    slider.update = function(selection) {\n      selection.each(update);\n    };\n\n    function update() {\n      var left = scale.invert(value) * 100;\n      d3.select(this).select(nub)\n        .style('left', left + '%')\n        .select('.value')\n          .text(format(value));\n    }\n\n    function dragstart() {\n      var e = d3.event,\n          o = e.sourceEvent,\n          p = o.type === 'touchstart'\n            ? d3.touches(root.node())[0]\n            : d3.mouse(root.node());\n      e.x = p[0];\n      e.y = p[1];\n      dragging = true;\n      dragmove();\n    }\n\n    function dragmove() {\n      var e = d3.event,\n          w = getWidth(root.node()),\n          x = Math.max(0, Math.min(e.x, w)),\n          u = x / w,\n          v = scale(u);\n\n      if (value != v) {\n        value = v;\n        dispatch.change({\n          x: x,\n          u: u,\n          value: value,\n          sourceEvent: e.sourceEvent\n        });\n      }\n\n      root.each(update);\n    }\n\n    function dragend() {\n      var e = d3.event;\n      // console.log('[drag] end');\n      dragging = false;\n    }\n\n    function getWidth(node) {\n      return node.getBoundingClientRect().width;\n    }\n\n    d3.rebind(slider, dispatch, 'on');\n    return slider;\n  };\n\n  /**\n   * Create a margin object {top, right, left, bottom} from any \n   * of the following types:\n   *\n   * - string: coerce to a number\n   * - number: a margin object with equal top, right, left and\n   *   bottom values\n   * - array: read the values as [top, right, bottom, left] if there\n   *   are 4 or more elements; otherwise read as [vertical,\n   *   horizontal]\n   * - object: set top, right, bottom and left keys to 0 if not set,\n   *   then return the object\n   * @name eiti.ui.margin\n   *\n   * @param {*} input\n   */\n  eiti.ui.margin = function(d) {\n    switch (typeof d) {\n      case 'string':\n        d = +d || 0;\n      case 'number':\n        return {left: d, top: d, right: d, bottom: d};\n      case 'undefined':\n        return {left: 0, top: 0, right: 0, bottom: 0};\n    }\n    if (Array.isArray(d)) {\n      return d.length >= 4\n        ? {top: d[0], right: d[1], bottom: d[2], left: d[3]}\n        : {top: d[0], right: d[1], bottom: d[0], left: d[1]};\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(k) {\n      if (!d.hasOwnProperty(k)) d[k] = 0;\n    });\n    return d;\n  };\n\n  eiti.util = {};\n\n  /**\n   * Extend objects with additional properties, a la `$.extend()`.\n   * @name eiti.util.extend\n   *\n   * @param {Object} base   the base object onto which all other\n   *                        properties will be added\n   * @param {Object=} other one or more additional objects with\n   *                        properties to be copied\n   * @return {Object} the `base` object with added properties\n   */\n  eiti.util.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(o) {\n      for (var key in o) {\n        obj[key] = o[key];\n      }\n    });\n    return obj;\n  };\n\n  /**\n   * Force a reset of location.hash so that the browser (hopefully)\n   * scrolls to the element with the fragment identifier and toggles\n   * the :target pseudo-class.\n   * @name eiti.util.jiggleHash\n   *\n   * @return {Boolean}\n   */\n  eiti.util.jiggleHash = function() {\n    var hash = location.hash;\n    if (hash) {\n      location.hash = '';\n      location.hash = hash;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * d3 helper for bringing an element to the front among its\n   * siblings. Use it with an event listener, e.g.:\n   * @name eiti.util.bringToFront\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront);\n   */\n  eiti.util.bringToFront = function() {\n    this._nextSibling = this.nextSibling;\n    this.parentNode.appendChild(this);\n  };\n\n  /**\n   * The compliment to {@link bringToFront}, returns an\n   * element to its previous position among its siblings.\n   * @name eiti.util.sendToBack\n   *\n   * @example\n   * d3.selectAll('svg path')\n   *   .on('mouseover', eiti.util.bringToFront)\n   *   .on('mouseout', eiti.util.sendToBack);\n   */\n  eiti.util.sendToBack = function() {\n    this.parentNode.insertBefore(this, this._nextSibling);\n    delete this._nextSibling;\n  };\n\n  eiti.format = {};\n\n  /**\n   * Create a composite format that wraps a d3 format (or any other\n   * formatting function) with a transform function.\n   * @name eiti.format.transform\n   * @param {String|Function} format\n   * @param {Function} transform\n   * @return {Function}\n   */\n  eiti.format.transform = function(format, transform) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    return function(d) {\n      return transform(format(d) || '');\n    };\n  };\n\n  /**\n   * Create a range formatter that strips the preceding `$`\n   * from the second value to produce strings like `$10m - 20m`\n   * instead of `$10m - $20m`.\n   * @name eiti.format.range\n   * @param {String|Function} format\n   * @param {String} [glue]\n   * @return {Function}\n   */\n  eiti.format.range = function(format, glue) {\n    if (typeof format === 'string') {\n      format = d3.format(format);\n    }\n    if (!glue) glue = '  ';\n    return function(range) {\n      range = range.map(function(d, i) {\n        var str = format(d);\n        return i > 0 ? str.replace('$', '') : str;\n      });\n      /*\n      // suffix de-duping\n      var suffix = range.map(function(str) {\n        var match = str.match(/[a-z]$/);\n        return match ? match[0] : null;\n      });\n      if (suffix[0] === suffix[1]) {\n        range[0] = range[0].substr(0, range[0].length - 1);\n      }\n      */\n      return range.join(glue);\n    };\n  };\n\n  /**\n   * Produces international system/metric form, e.g. `4.1M`\n   * @name eiti.format.metric\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.metric = d3.format('.2s');\n\n  /**\n   * Produces whole dollar strings with thousands separators, e.g.\n   * `$1,234,567`.\n   * @name eiti.format.dollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollars = d3.format('$,.0f');\n\n  /**\n   * Produces dollar strings with thousands separators and 2-decimal\n   * cents, e.g. `$1,234,567.89`.\n   * @name eiti.format.dollarsAndCents\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.dollarsAndCents = d3.format('$,.2f');\n\n  /**\n   * Produces short dollar strings in SI format with 1 decimal,\n   * e.g. `$1.2m` or `$4.8b`.\n   * @name eiti.format.shortDollars\n   * @function\n   * @param {Number} num\n   * @return {String}\n   */\n  eiti.format.shortDollars = eiti.format.transform('$,.2s', function(str) {\n    var suffix = {k: 'k', M: 'm', G: 'b'};\n    return str.replace(/[kMG]$/, function(s) {\n      return suffix[s] || s;\n    });\n  });\n\n  function getter(key) {\n    if (typeof key === 'function') return key;\n    return function(d) { return d[key]; };\n  }\n\n}"
    },
    "name": "eiti.format.transform",
    "params": [
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "String"
            },
            {
              "type": "NameExpression",
              "name": "Function"
            }
          ]
        },
        "name": "format"
      },
      {
        "title": "param",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        },
        "name": "transform"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "Function"
        }
      }
    ],
    "kind": "function",
    "memberof": "eiti.format",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "eiti.format.transform"
    ]
  }
]