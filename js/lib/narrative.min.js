/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 43);
/******/ })
/************************************************************************/
/******/ ({

/***/ 1:
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./js/components/sticky.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

(function(exports) {
  'use strict';

  var sticky = __webpack_require__(/*! stickyfill-web-module */ 3)();
  var stickies = [];
  var doc = d3.select(document);
  var win = d3.select(window);

  [].forEach.call(
    document.querySelectorAll('.sticky'),
    function(el) {
      stickies.push(el);
      sticky.add(el);
      if (!el.classList.contains('mobile-nav')) {
        var isNav = el.classList.contains('sticky_nav');
        var preSticky = document.createElement('div');
        el.parentNode.insertBefore(preSticky, el)
          .setAttribute('class', 'pre-sticky');

        if (isNav) {
          preSticky.classList.add('pre-sticky-small');
        }
      }
    }
  );

  var watch = function() {
    stickies.forEach(function(sticky) {

      var isFixed = d3.select(sticky).style('position') === 'fixed';
      var atTop = (sticky.lastTop !== sticky.offsetTop) || isFixed;
      var isStuck = sticky.classList.contains('stuck');

      sticky.lastTop = sticky.offsetTop;
      if (atTop && !isStuck) {
        sticky.classList.add('stuck');
      } else if (!atTop && isStuck) {
        sticky.classList.remove('stuck');
      }
    });
  };

  var throttledWatch = eiti.util.throttle(watch, 100);
  doc.on('scroll.sticky', watch);
  win.on('resize.sticky', throttledWatch);

  watch();

  exports.stickyfill = sticky;

})(window);


/***/ }),

/***/ 3:
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** ./~/stickyfill-web-module/dist/stickyfill.js ***!
  \****************************************************/
/***/ (function(module, exports) {

/*!
 * Stickyfill -- `position: sticky` polyfill
 * v. 1.1.11 | https://github.com/18F/stickyfill
 * Copyright Brian Hedberg | 
 *
 * MIT License
 */
/*!
* Stickyfill -- `position: sticky` polyfill
* v. 1.1.4 | https://github.com/wilddeer/stickyfill
* Copyright Oleg Korsunsky | http://wd.dizaina.net/
*
* MIT License
*/

 module.exports = (function(doc, win) {
    if (!doc) {
        doc = document;
    }

    if (!win) {
        win = window;
    }

    var watchArray = [],
        scroll,
        initialized = false,
        html = doc.documentElement,
        noop = function() {},
        checkTimer,

        //visibility API strings
        hiddenPropertyName = 'hidden',
        visibilityChangeEventName = 'visibilitychange';

    //fallback to prefixed names in old webkit browsers
    if (doc.webkitHidden !== undefined) {
        hiddenPropertyName = 'webkitHidden';
        visibilityChangeEventName = 'webkitvisibilitychange';
    }

    //test getComputedStyle
    if (!win.getComputedStyle) {
        seppuku();
    }

    //test for native support
    var prefixes = ['', '-webkit-', '-moz-', '-ms-'],
        block = document.createElement('div');

    for (var i = prefixes.length - 1; i >= 0; i--) {
        try {
            block.style.position = prefixes[i] + 'sticky';
        }
        catch(e) {}
        if (block.style.position != '') {
            seppuku();
        }
    }

    updateScrollPos();

    //commit seppuku!
    function seppuku() {
        init = add = rebuild = pause = stop = kill = noop;
    }

    function mergeObjects(targetObj, sourceObject) {
        for (var key in sourceObject) {
            if (sourceObject.hasOwnProperty(key)) {
                targetObj[key] = sourceObject[key];
            }
        }
    }

    function parseNumeric(val) {
        return parseFloat(val) || 0;
    }

    function updateScrollPos() {
        scroll = {
            top: win.pageYOffset,
            left: win.pageXOffset
        };
    }

    function onScroll() {
        if (win.pageXOffset != scroll.left) {
            updateScrollPos();
            rebuild();
            return;
        }

        if (win.pageYOffset != scroll.top) {
            updateScrollPos();
            recalcAllPos();
        }
    }

    //fixes flickering
    function onWheel(event) {
        setTimeout(function() {
            if (win.pageYOffset != scroll.top) {
                scroll.top = win.pageYOffset;
                recalcAllPos();
            }
        }, 0);
    }

    function recalcAllPos() {
        for (var i = watchArray.length - 1; i >= 0; i--) {
            recalcElementPos(watchArray[i]);
        }
    }

    function recalcElementPos(el) {
        if (!el.inited) return;

        var currentMode = (scroll.top <= el.limit.start? 0: scroll.top >= el.limit.end? 2: 1);

        if (el.mode != currentMode) {
            switchElementMode(el, currentMode);
        }
    }

    //checks whether stickies start or stop positions have changed
    function fastCheck() {
        for (var i = watchArray.length - 1; i >= 0; i--) {
            if (!watchArray[i].inited) continue;

            var deltaTop = Math.abs(getDocOffsetTop(watchArray[i].clone) - watchArray[i].docOffsetTop),
                deltaHeight = Math.abs(watchArray[i].parent.node.offsetHeight - watchArray[i].parent.height);

            if (deltaTop >= 2 || deltaHeight >= 2) return false;
        }
        return true;
    }

    function initElement(el) {
        if (isNaN(parseFloat(el.computed.top)) || el.isCell || el.computed.display == 'none') return;

        el.inited = true;

        if (!el.clone) clone(el);
        if (el.parent.computed.position != 'absolute' &&
            el.parent.computed.position != 'relative') el.parent.node.style.position = 'relative';

        recalcElementPos(el);

        el.parent.height = el.parent.node.offsetHeight;
        el.docOffsetTop = getDocOffsetTop(el.clone);
    }

    function deinitElement(el) {
        var deinitParent = true;

        el.clone && killClone(el);
        mergeObjects(el.node.style, el.css);

        //check whether element's parent is used by other stickies
        for (var i = watchArray.length - 1; i >= 0; i--) {
            if (watchArray[i].node !== el.node && watchArray[i].parent.node === el.parent.node) {
                deinitParent = false;
                break;
            }
        };

        if (deinitParent) el.parent.node.style.position = el.parent.css.position;
        el.mode = -1;
    }

    function initAll() {
        for (var i = watchArray.length - 1; i >= 0; i--) {
            initElement(watchArray[i]);
        }
    }

    function deinitAll() {
        for (var i = watchArray.length - 1; i >= 0; i--) {
            deinitElement(watchArray[i]);
        }
    }

    function switchElementMode(el, mode) {
        var nodeStyle = el.node.style;

        switch (mode) {
            case 0:
                nodeStyle.position = 'absolute';
                nodeStyle.left = el.offset.left + 'px';
                nodeStyle.right = el.offset.right + 'px';
                nodeStyle.top = el.offset.top + 'px';
                nodeStyle.bottom = 'auto';
                nodeStyle.width = 'auto';
                nodeStyle.marginLeft = 0;
                nodeStyle.marginRight = 0;
                nodeStyle.marginTop = 0;
                break;

            case 1:
                nodeStyle.position = 'fixed';
                nodeStyle.left = el.box.left + 'px';
                nodeStyle.right = el.box.right + 'px';
                nodeStyle.top = el.css.top;
                nodeStyle.bottom = 'auto';
                nodeStyle.width = 'auto';
                nodeStyle.marginLeft = 0;
                nodeStyle.marginRight = 0;
                nodeStyle.marginTop = 0;
                break;

            case 2:
                nodeStyle.position = 'absolute';
                nodeStyle.left = el.offset.left + 'px';
                nodeStyle.right = el.offset.right + 'px';
                nodeStyle.top = 'auto';
                nodeStyle.bottom = 0;
                nodeStyle.width = 'auto';
                nodeStyle.marginLeft = 0;
                nodeStyle.marginRight = 0;
                break;
        }

        el.mode = mode;
    }

    function clone(el) {
        el.clone = document.createElement('div');

        var refElement = el.node.nextSibling || el.node,
            cloneStyle = el.clone.style;

        cloneStyle.height = el.height + 'px';
        cloneStyle.width = el.width + 'px';
        cloneStyle.marginTop = el.computed.marginTop;
        cloneStyle.marginBottom = el.computed.marginBottom;
        cloneStyle.marginLeft = el.computed.marginLeft;
        cloneStyle.marginRight = el.computed.marginRight;
        cloneStyle.padding = cloneStyle.border = cloneStyle.borderSpacing = 0;
        cloneStyle.fontSize = '1em';
        cloneStyle.position = 'static';
        cloneStyle.cssFloat = el.computed.cssFloat;

        el.node.parentNode.insertBefore(el.clone, refElement);
    }

    function killClone(el) {
        el.clone.parentNode.removeChild(el.clone);
        el.clone = undefined;
    }

    function getElementParams(node) {
        var computedStyle = getComputedStyle(node),
            parentNode = node.parentNode,
            parentComputedStyle = getComputedStyle(parentNode),
            cachedPosition = node.style.position;

        node.style.position = 'relative';

        var computed = {
                top: computedStyle.top,
                marginTop: computedStyle.marginTop,
                marginBottom: computedStyle.marginBottom,
                marginLeft: computedStyle.marginLeft,
                marginRight: computedStyle.marginRight,
                cssFloat: computedStyle.cssFloat,
                display: computedStyle.display
            },
            numeric = {
                top: parseNumeric(computedStyle.top),
                marginBottom: parseNumeric(computedStyle.marginBottom),
                paddingLeft: parseNumeric(computedStyle.paddingLeft),
                paddingRight: parseNumeric(computedStyle.paddingRight),
                borderLeftWidth: parseNumeric(computedStyle.borderLeftWidth),
                borderRightWidth: parseNumeric(computedStyle.borderRightWidth)
            };

        node.style.position = cachedPosition;

        var css = {
                position: node.style.position,
                top: node.style.top,
                bottom: node.style.bottom,
                left: node.style.left,
                right: node.style.right,
                width: node.style.width,
                marginTop: node.style.marginTop,
                marginLeft: node.style.marginLeft,
                marginRight: node.style.marginRight
            },
            nodeOffset = getElementOffset(node),
            parentOffset = getElementOffset(parentNode),

            parent = {
                node: parentNode,
                css: {
                    position: parentNode.style.position
                },
                computed: {
                    position: parentComputedStyle.position
                },
                numeric: {
                    borderLeftWidth: parseNumeric(parentComputedStyle.borderLeftWidth),
                    borderRightWidth: parseNumeric(parentComputedStyle.borderRightWidth),
                    borderTopWidth: parseNumeric(parentComputedStyle.borderTopWidth),
                    borderBottomWidth: parseNumeric(parentComputedStyle.borderBottomWidth)
                }
            },

            el = {
                node: node,
                box: {
                    left: nodeOffset.win.left,
                    right: html.clientWidth - nodeOffset.win.right
                },
                offset: {
                    top: nodeOffset.win.top - parentOffset.win.top - parent.numeric.borderTopWidth,
                    left: nodeOffset.win.left - parentOffset.win.left - parent.numeric.borderLeftWidth,
                    right: -nodeOffset.win.right + parentOffset.win.right - parent.numeric.borderRightWidth
                },
                css: css,
                isCell: computedStyle.display == 'table-cell',
                computed: computed,
                numeric: numeric,
                width: nodeOffset.win.right - nodeOffset.win.left,
                height: nodeOffset.win.bottom - nodeOffset.win.top,
                mode: -1,
                inited: false,
                parent: parent,
                limit: {
                    start: nodeOffset.doc.top - numeric.top,
                    end: parentOffset.doc.top + parentNode.offsetHeight - parent.numeric.borderBottomWidth -
                        node.offsetHeight - numeric.top - numeric.marginBottom
                }
            };

        return el;
    }

    function getDocOffsetTop(node) {
        var docOffsetTop = 0;

        while (node) {
            docOffsetTop += node.offsetTop;
            node = node.offsetParent;
        }

        return docOffsetTop;
    }

    function getElementOffset(node) {
        var box = node.getBoundingClientRect();

            return {
                doc: {
                    top: box.top + win.pageYOffset,
                    left: box.left + win.pageXOffset
                },
                win: box
            };
    }

    function startFastCheckTimer() {
        checkTimer = setInterval(function() {
            !fastCheck() && rebuild();
        }, 500);
    }

    function stopFastCheckTimer() {
        clearInterval(checkTimer);
    }

    function handlePageVisibilityChange() {
        if (!initialized) return;

        if (document[hiddenPropertyName]) {
            stopFastCheckTimer();
        }
        else {
            startFastCheckTimer();
        }
    }

    function init() {
        if (initialized) return;

        updateScrollPos();
        initAll();

        win.addEventListener('scroll', onScroll, { passive: true });
        win.addEventListener('wheel', onWheel, { passive: true });

        //watch for width changes
        win.addEventListener('resize', rebuild);
        win.addEventListener('orientationchange', rebuild);

        //watch for page visibility
        doc.addEventListener(visibilityChangeEventName, handlePageVisibilityChange);

        startFastCheckTimer();

        initialized = true;
    }

    function rebuild() {
        if (!initialized) return;

        deinitAll();

        for (var i = watchArray.length - 1; i >= 0; i--) {
            watchArray[i] = getElementParams(watchArray[i].node);
        }

        initAll();
    }

    function pause() {
        win.removeEventListener('scroll', onScroll);
        win.removeEventListener('wheel', onWheel);
        win.removeEventListener('resize', rebuild);
        win.removeEventListener('orientationchange', rebuild);
        doc.removeEventListener(visibilityChangeEventName, handlePageVisibilityChange);

        stopFastCheckTimer();

        initialized = false;
    }

    function stop() {
        pause();
        deinitAll();
    }

    function kill() {
        stop();

        //empty the array without loosing the references,
        //the most performant method according to http://jsperf.com/empty-javascript-array
        while (watchArray.length) {
            watchArray.pop();
        }
    }

    function add(node) {
        //check if Stickyfill is already applied to the node
        for (var i = watchArray.length - 1; i >= 0; i--) {
            if (watchArray[i].node === node) return;
        };

        var el = getElementParams(node);

        watchArray.push(el);

        if (!initialized) {
            init();
        }
        else {
            initElement(el);
        }
    }

    function remove(node) {
        for (var i = watchArray.length - 1; i >= 0; i--) {
            if (watchArray[i].node === node) {
                deinitElement(watchArray[i]);
                watchArray.splice(i, 1);
            }
        };
    }

    //expose Stickyfill
    return {
        stickies: watchArray,
        add: add,
        remove: remove,
        init: init,
        rebuild: rebuild,
        pause: pause,
        stop: stop,
        kill: kill
    };
});


/***/ }),

/***/ 43:
/* unknown exports provided */
/* all exports used */
/*!*****************************!*\
  !*** ./js/src/narrative.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

(function(exports) {
  'use strict';

  __webpack_require__(/*! ./../components/sticky.js */ 1);

  var OpenListNav = __webpack_require__(/*! ../components/open-list-nav.js */ 7);

  // exporting instance of OpenListNav because openListNav is
  // referenced in the markup:
  // _includes/hash_selecor.html
  exports.openListNav = new OpenListNav();

})(window);


/***/ }),

/***/ 7:
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./js/components/open-list-nav.js ***!
  \****************************************/
/***/ (function(module, exports) {

(function(exports) {
    function getScrollTop() {
      return (window.pageYOffset !== undefined)
        ? window.pageYOffset
        : (document.documentElement
          || document.body.parentNode
          || document.body).scrollTop;
    }



    exports.OpenListNav = function() {
      // init OpenListNav Properties
      this.active = this.stripHash(window.location.hash) || 'intro';
      this.navItems = document.querySelectorAll('[data-nav-item]');
      this.navSelect = $('[data-nav-options]');
      this.navIsSelect = this.navSelect.length > 1;
      // initialize at maximum value
      this.defaultTop = 1e8;
      this.closestToTop = this.defaultTop;
      this.viewportElements = 0;
      this.subnavItemClass = 'sticky_nav-nav_item-sub';
      this.scrollTop = {
        current: getScrollTop(),
        prev: getScrollTop(),
        direction: 'down'
      };

      this.registerEventHandlers();
    };

    exports.OpenListNav.prototype = {
      updateScrollTop: function() {
        this.scrollTop.prev = this.scrollTop.current;
        this.scrollTop.current = getScrollTop();
        this.scrollTop.direction = (
          this.scrollTop.current >= this.scrollTop.prev
        ) ? 'down' : 'up';
      },

      isActiveElement: function(el) {
        if (!el) {
          return;
        }

        var status = false;
        var rect = el.getBoundingClientRect();

        var elementInViewport = rect.bottom > 0 &&
            rect.right > 0 &&
            rect.left < (window.innerWidth ||
                         document.documentElement.clientWidth) &&
            rect.top < (window.innerHeight ||
                        document.documentElement.clientHeight);

        var elTop = Math.abs(rect.top);

        if (elementInViewport && (elTop < this.closestToTop) ) {
          this.closestToTop = elTop;
          this.viewportElements++;
          status = true;
        } else if (elementInViewport &&
                  (this.viewportElements < 1) &&
                  (elTop >= this.closestToTop) ) {
          this.viewportElements++;
          status = true;
        }

        return status;
      },

      stripHash: function(str) {
        return str.charAt(0) === '#'
          ? str.slice(1, str.length)
          : str;
      },

      resetTop: function() {
        this.closestToTop = this.defaultTop;
        this.viewportElements = 0;
      },

      removeActive: function() {
        this.active = null;
        for (var i = 0; i < this.navItems.length; i++) {
          this.navItems[i].setAttribute('data-active', false);
        }
      },

      addActive: function(el, name, parent) {
        if (!el) {
          el = document.querySelector('[data-nav-item="' + name + '"]');
          parent = document.querySelector('[data-nav-item="' + parent + '"]');
          this.active = this.stripHash(name);
          el.setAttribute('data-active', true);
          if (parent) {
            parent.setAttribute('data-active', true);
          }
        } else {
          this.active = this.stripHash(el.getAttribute('data-nav-item'));
          el.setAttribute('data-active', true);
          if (parent) {
            parent.setAttribute('data-active', true);
          }
        }
      },

      update: function(el, name, parent) {
        this.removeActive();
        this.addActive(el, name, parent);
      },

      updateSelectField: function(newValue) {
        if (newValue) {
          this.navSelect.val(newValue);
        }
      },

      registerEventHandlers: function() {
        var self = this;
        if (!this.navIsSelect) {
          for (var i = 0; i < this.navItems.length; i++) {

            var item = this.navItems[i];

            if (!document.getElementById(item.dataset.navItem) && item) {
              item.setAttribute('aria-hidden', true);
              item.outerHTML = '';
              item = undefined;
            } else {
              item.addEventListener('click', function() {
                self.update(this);
              });
            }
          }
        }

        window.addEventListener('scroll', function() {
          self.updateScrollTop();
          // TODO: throttle
          self.detectNavChange();
        });

        window.addEventListener('resize', function() {
          // TODO: throttle
          self.detectNavChange();
        });

      },

      changeHandler: function(selector) {
        window.location.hash = selector.value;
      },

      detectNavChange: function() {
        var self = this;

        var items = this.navIsSelect
          ? this.navSelect
          : this.navItems;

        Array.prototype.forEach.call(items, function(item) {
          var parentName,
            newName,
            header,
            isActiveElement;

          if (!self.navIsSelect) {
            header = document.getElementById(item.dataset.navItem);

            isActiveElement = self.isActiveElement(header);

            if (isActiveElement) {
              newName = header.id;

              if (item.classList.contains(self.subnavItemClass)) {
                parentName = item.parentElement.previousElementSibling
                .getAttribute('data-nav-item');
              }

              self.update(null, newName, parentName);

            }
          } else if (self.navIsSelect) {
            Array.prototype.forEach.call(item, function(option) {

              header = document.getElementById(option.value);
              isActiveElement = self.isActiveElement(header);

              if (isActiveElement && self.navIsSelect) {
                newName = option.value;
                self.updateSelectField(newName);
              }
            });
          }

        });

        this.resetTop();
      }
    };

    module.exports = exports.OpenListNav;
  })(this);


/***/ })

/******/ });
//# sourceMappingURL=narrative.min.js.map