/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	(function(exports) {
	  'use strict';

	  __webpack_require__(3);

	  var OpenListNav = __webpack_require__(36);

	  // exporting instance of OpenListNav because openListNav is
	  // referenced in the markup:
	  // _includes/hash_selecor.html
	  exports.openListNav = new OpenListNav();

	})(window);


/***/ },

/***/ 3:
/***/ function(module, exports, __webpack_require__) {

	(function(exports) {

	  var Stickyfill = __webpack_require__(4);
	  var stickyfill = Stickyfill();

	  var stickyElements = document.getElementsByClassName('sticky');

	  for (var i = stickyElements.length - 1; i >= 0; i--) {
	      stickyfill.add(stickyElements[i]);
	  }
	  exports.Stickyfill = Stickyfill;
	  exports.stickyfill = stickyfill;


	})(this);


/***/ },

/***/ 4:
/***/ function(module, exports) {

	/*!
	 * Stickyfill -- `position: sticky` polyfill
	 * v. 1.1.1 | https://github.com/wilddeer/stickyfill
	 * Copyright Oleg Korsunsky | http://wd.dizaina.net/
	 *
	 * MIT License
	 */

	module.exports = (function(doc, win) {
	    if (!doc) {
	        doc = document;
	    }

	    if (!win) {
	        win = window;
	    }
	    
	    var watchArray = [],
	        scroll,
	        initialized = false,
	        html = doc.documentElement,
	        noop = function() {},
	        checkTimer,

	        //visibility API strings
	        hiddenPropertyName = 'hidden',
	        visibilityChangeEventName = 'visibilitychange';

	    //fallback to prefixed names in old webkit browsers
	    if (doc.webkitHidden !== undefined) {
	        hiddenPropertyName = 'webkitHidden';
	        visibilityChangeEventName = 'webkitvisibilitychange';
	    }

	    //test getComputedStyle
	    if (!win.getComputedStyle) {
	        seppuku();
	    }

	    //test for native support
	    var prefixes = ['', '-webkit-', '-moz-', '-ms-'],
	        block = document.createElement('div');

	    for (var i = prefixes.length - 1; i >= 0; i--) {
	        try {
	            block.style.position = prefixes[i] + 'sticky';
	        }
	        catch(e) {}
	        if (block.style.position != '') {
	            seppuku();
	        }
	    }

	    updateScrollPos();

	    //commit seppuku!
	    function seppuku() {
	        init = add = rebuild = pause = stop = kill = noop;
	    }

	    function mergeObjects(targetObj, sourceObject) {
	        for (key in sourceObject) {
	            if (sourceObject.hasOwnProperty(key)) {
	                targetObj[key] = sourceObject[key];
	            }
	        }
	    }

	    function parseNumeric(val) {
	        return parseFloat(val) || 0;
	    }

	    function updateScrollPos() {
	        scroll = {
	            top: win.pageYOffset,
	            left: win.pageXOffset
	        };
	    }

	    function onScroll() {
	        if (win.pageXOffset != scroll.left) {
	            updateScrollPos();
	            rebuild();
	            return;
	        }
	        
	        if (win.pageYOffset != scroll.top) {
	            updateScrollPos();
	            recalcAllPos();
	        }
	    }

	    //fixes flickering
	    function onWheel(event) {
	        setTimeout(function() {
	            if (win.pageYOffset != scroll.top) {
	                scroll.top = win.pageYOffset;
	                recalcAllPos();
	            }
	        }, 0);
	    }

	    function recalcAllPos() {
	        for (var i = watchArray.length - 1; i >= 0; i--) {
	            recalcElementPos(watchArray[i]);
	        }
	    }

	    function recalcElementPos(el) {
	        if (!el.inited) return;

	        var currentMode = (scroll.top <= el.limit.start? 0: scroll.top >= el.limit.end? 2: 1);

	        if (el.mode != currentMode) {
	            switchElementMode(el, currentMode);
	        }
	    }

	    //checks whether stickies start or stop positions have changed
	    function fastCheck() {
	        for (var i = watchArray.length - 1; i >= 0; i--) {
	            if (!watchArray[i].inited) continue;

	            var deltaTop = Math.abs(getDocOffsetTop(watchArray[i].clone) - watchArray[i].docOffsetTop),
	                deltaHeight = Math.abs(watchArray[i].parent.node.offsetHeight - watchArray[i].parent.height);

	            if (deltaTop >= 2 || deltaHeight >= 2) return false;
	        }
	        return true;
	    }

	    function initElement(el) {
	        if (isNaN(parseFloat(el.computed.top)) || el.isCell) return;

	        el.inited = true;

	        if (!el.clone) clone(el);
	        if (el.parent.computed.position != 'absolute' &&
	            el.parent.computed.position != 'relative') el.parent.node.style.position = 'relative';

	        recalcElementPos(el);

	        el.parent.height = el.parent.node.offsetHeight;
	        el.docOffsetTop = getDocOffsetTop(el.clone);
	    }

	    function deinitElement(el) {
	        var deinitParent = true;

	        el.clone && killClone(el);
	        mergeObjects(el.node.style, el.css);

	        //check whether element's parent is used by other stickies
	        for (var i = watchArray.length - 1; i >= 0; i--) {
	            if (watchArray[i].node !== el.node && watchArray[i].parent.node === el.parent.node) {
	                deinitParent = false;
	                break;
	            }
	        };

	        if (deinitParent) el.parent.node.style.position = el.parent.css.position;
	        el.mode = -1;
	    }

	    function initAll() {
	        for (var i = watchArray.length - 1; i >= 0; i--) {
	            initElement(watchArray[i]);
	        }
	    }

	    function deinitAll() {
	        for (var i = watchArray.length - 1; i >= 0; i--) {
	            deinitElement(watchArray[i]);
	        }
	    }

	    function switchElementMode(el, mode) {
	        var nodeStyle = el.node.style;

	        switch (mode) {
	            case 0:
	                nodeStyle.position = 'absolute';
	                nodeStyle.left = el.offset.left + 'px';
	                nodeStyle.right = el.offset.right + 'px';
	                nodeStyle.top = el.offset.top + 'px';
	                nodeStyle.bottom = 'auto';
	                nodeStyle.width = 'auto';
	                nodeStyle.marginLeft = 0;
	                nodeStyle.marginRight = 0;
	                nodeStyle.marginTop = 0;
	                break;

	            case 1:
	                nodeStyle.position = 'fixed';
	                nodeStyle.left = el.box.left + 'px';
	                nodeStyle.right = el.box.right + 'px';
	                nodeStyle.top = el.css.top;
	                nodeStyle.bottom = 'auto';
	                nodeStyle.width = 'auto';
	                nodeStyle.marginLeft = 0;
	                nodeStyle.marginRight = 0;
	                nodeStyle.marginTop = 0;
	                break;

	            case 2:
	                nodeStyle.position = 'absolute';
	                nodeStyle.left = el.offset.left + 'px';
	                nodeStyle.right = el.offset.right + 'px';
	                nodeStyle.top = 'auto';
	                nodeStyle.bottom = 0;
	                nodeStyle.width = 'auto';
	                nodeStyle.marginLeft = 0;
	                nodeStyle.marginRight = 0;
	                break;
	        }

	        el.mode = mode;
	    }

	    function clone(el) {
	        el.clone = document.createElement('div');

	        var refElement = el.node.nextSibling || el.node,
	            cloneStyle = el.clone.style;

	        cloneStyle.height = el.height + 'px';
	        cloneStyle.width = el.width + 'px';
	        cloneStyle.marginTop = el.computed.marginTop;
	        cloneStyle.marginBottom = el.computed.marginBottom;
	        cloneStyle.marginLeft = el.computed.marginLeft;
	        cloneStyle.marginRight = el.computed.marginRight;
	        cloneStyle.padding = cloneStyle.border = cloneStyle.borderSpacing = 0;
	        cloneStyle.fontSize = '1em';
	        cloneStyle.position = 'static';
	        cloneStyle.cssFloat = el.computed.cssFloat;

	        el.node.parentNode.insertBefore(el.clone, refElement);
	    }

	    function killClone(el) {
	        el.clone.parentNode.removeChild(el.clone);
	        el.clone = undefined;
	    }

	    function getElementParams(node) {
	        var computedStyle = getComputedStyle(node),
	            parentNode = node.parentNode,
	            parentComputedStyle = getComputedStyle(parentNode),
	            cachedPosition = node.style.position;

	        node.style.position = 'relative';

	        var computed = {
	                top: computedStyle.top,
	                marginTop: computedStyle.marginTop,
	                marginBottom: computedStyle.marginBottom,
	                marginLeft: computedStyle.marginLeft,
	                marginRight: computedStyle.marginRight,
	                cssFloat: computedStyle.cssFloat
	            },
	            numeric = {
	                top: parseNumeric(computedStyle.top),
	                marginBottom: parseNumeric(computedStyle.marginBottom),
	                paddingLeft: parseNumeric(computedStyle.paddingLeft),
	                paddingRight: parseNumeric(computedStyle.paddingRight),
	                borderLeftWidth: parseNumeric(computedStyle.borderLeftWidth),
	                borderRightWidth: parseNumeric(computedStyle.borderRightWidth)
	            };

	        node.style.position = cachedPosition;

	        var css = {
	                position: node.style.position,
	                top: node.style.top,
	                bottom: node.style.bottom,
	                left: node.style.left,
	                right: node.style.right,
	                width: node.style.width,
	                marginTop: node.style.marginTop,
	                marginLeft: node.style.marginLeft,
	                marginRight: node.style.marginRight
	            },
	            nodeOffset = getElementOffset(node),
	            parentOffset = getElementOffset(parentNode),
	            
	            parent = {
	                node: parentNode,
	                css: {
	                    position: parentNode.style.position
	                },
	                computed: {
	                    position: parentComputedStyle.position
	                },
	                numeric: {
	                    borderLeftWidth: parseNumeric(parentComputedStyle.borderLeftWidth),
	                    borderRightWidth: parseNumeric(parentComputedStyle.borderRightWidth),
	                    borderTopWidth: parseNumeric(parentComputedStyle.borderTopWidth),
	                    borderBottomWidth: parseNumeric(parentComputedStyle.borderBottomWidth)
	                }
	            },

	            el = {
	                node: node,
	                box: {
	                    left: nodeOffset.win.left,
	                    right: html.clientWidth - nodeOffset.win.right
	                },
	                offset: {
	                    top: nodeOffset.win.top - parentOffset.win.top - parent.numeric.borderTopWidth,
	                    left: nodeOffset.win.left - parentOffset.win.left - parent.numeric.borderLeftWidth,
	                    right: -nodeOffset.win.right + parentOffset.win.right - parent.numeric.borderRightWidth
	                },
	                css: css,
	                isCell: computedStyle.display == 'table-cell',
	                computed: computed,
	                numeric: numeric,
	                width: nodeOffset.win.right - nodeOffset.win.left,
	                height: nodeOffset.win.bottom - nodeOffset.win.top,
	                mode: -1,
	                inited: false,
	                parent: parent,
	                limit: {
	                    start: nodeOffset.doc.top - numeric.top,
	                    end: parentOffset.doc.top + parentNode.offsetHeight - parent.numeric.borderBottomWidth -
	                        node.offsetHeight - numeric.top - numeric.marginBottom
	                }
	            };

	        return el;
	    }

	    function getDocOffsetTop(node) {
	        var docOffsetTop = 0;

	        while (node) {
	            docOffsetTop += node.offsetTop;
	            node = node.offsetParent;
	        }

	        return docOffsetTop;
	    }

	    function getElementOffset(node) {
	        var box = node.getBoundingClientRect();

	            return {
	                doc: {
	                    top: box.top + win.pageYOffset,
	                    left: box.left + win.pageXOffset
	                },
	                win: box
	            };
	    }

	    function startFastCheckTimer() {
	        checkTimer = setInterval(function() {
	            !fastCheck() && rebuild();
	        }, 500);
	    }

	    function stopFastCheckTimer() {
	        clearInterval(checkTimer);
	    }

	    function handlePageVisibilityChange() {
	        if (!initialized) return;

	        if (document[hiddenPropertyName]) {
	            stopFastCheckTimer();
	        }
	        else {
	            startFastCheckTimer();
	        }
	    }

	    function init() {
	        if (initialized) return;

	        updateScrollPos();
	        initAll();

	        win.addEventListener('scroll', onScroll);
	        win.addEventListener('wheel', onWheel);

	        //watch for width changes
	        win.addEventListener('resize', rebuild);
	        win.addEventListener('orientationchange', rebuild);

	        //watch for page visibility
	        doc.addEventListener(visibilityChangeEventName, handlePageVisibilityChange);

	        startFastCheckTimer();

	        initialized = true;
	    }

	    function rebuild() {
	        if (!initialized) return;

	        deinitAll();
	        
	        for (var i = watchArray.length - 1; i >= 0; i--) {
	            watchArray[i] = getElementParams(watchArray[i].node);
	        }
	        
	        initAll();
	    }

	    function pause() {
	        win.removeEventListener('scroll', onScroll);
	        win.removeEventListener('wheel', onWheel);
	        win.removeEventListener('resize', rebuild);
	        win.removeEventListener('orientationchange', rebuild);
	        doc.removeEventListener(visibilityChangeEventName, handlePageVisibilityChange);

	        stopFastCheckTimer();

	        initialized = false;
	    }

	    function stop() {
	        pause();
	        deinitAll(); 
	    }

	    function kill() {
	        stop();

	        //empty the array without loosing the references,
	        //the most performant method according to http://jsperf.com/empty-javascript-array
	        while (watchArray.length) {
	            watchArray.pop();
	        }
	    }

	    function add(node) {
	        //check if Stickyfill is already applied to the node
	        for (var i = watchArray.length - 1; i >= 0; i--) {
	            if (watchArray[i].node === node) return;
	        };

	        var el = getElementParams(node);

	        watchArray.push(el);

	        if (!initialized) {
	            init();
	        }
	        else {
	            initElement(el);
	        }
	    }

	    function remove(node) {
	        for (var i = watchArray.length - 1; i >= 0; i--) {
	            if (watchArray[i].node === node) {
	                deinitElement(watchArray[i]);
	                watchArray.splice(i, 1);
	            }
	        };
	    }

	    //expose Stickyfill
	    return {
	        stickies: watchArray,
	        add: add,
	        remove: remove,
	        init: init,
	        rebuild: rebuild,
	        pause: pause,
	        stop: stop,
	        kill: kill
	    };
	})

/***/ },

/***/ 36:
/***/ function(module, exports) {

	(function(exports) {
	    function getScrollTop() {
	      return (window.pageYOffset !== undefined)
	        ? window.pageYOffset
	        : (document.documentElement
	          || document.body.parentNode
	          || document.body).scrollTop;
	    }



	    exports.OpenListNav = function() {
	      // init OpenListNav Properties
	      this.active = this.stripHash(window.location.hash) || 'intro';
	      this.navItems = document.querySelectorAll('[data-nav-item]');
	      this.navSelect = $('[data-nav-options]');
	      this.navIsSelect = !!this.navSelect.length;
	      // initialize at maximum value
	      this.defaultTop = 1e8;
	      this.closestToTop = this.defaultTop;
	      this.viewportElements = 0;
	      this.subnavItemClass = 'sticky_nav-nav_item-sub';
	      this.scrollTop = {
	        current: getScrollTop(),
	        prev: getScrollTop(),
	        direction: 'down'
	      };

	      this.registerEventHandlers();
	    };

	    exports.OpenListNav.prototype = {
	      updateScrollTop: function() {
	        this.scrollTop.prev = this.scrollTop.current;
	        this.scrollTop.current = getScrollTop();
	        this.scrollTop.direction = (this.scrollTop.current >= this.scrollTop.prev)
	          ? 'down'
	          : 'up';
	      },

	      isActiveElement: function(el) {
	        if (!el) {
	          return;
	        }

	        var status = false;
	        var rect = el.getBoundingClientRect();

	        var elementInViewport = rect.bottom > 0 &&
	            rect.right > 0 &&
	            rect.left < (window.innerWidth ||
	                         document.documentElement.clientWidth) &&
	            rect.top < (window.innerHeight ||
	                        document.documentElement.clientHeight);

	        var elTop = Math.abs(rect.top);

	        if (elementInViewport && (elTop < this.closestToTop) ) {
	          this.closestToTop = elTop;
	          this.viewportElements++;
	          status = true;
	        } else if (elementInViewport &&
	                  (this.viewportElements < 1) &&
	                  (elTop >= this.closestToTop) ) {
	          this.viewportElements++;
	          status = true;
	        }

	        return status;
	      },

	      stripHash: function (str) {
	        return str.charAt(0) === '#'
	          ? str.slice(1, str.length)
	          : str;
	      },

	      resetTop: function(){
	        this.closestToTop = this.defaultTop;
	        this.viewportElements = 0;
	      },

	      removeActive: function(){
	        this.active = null;
	        for (var i = 0; i < this.navItems.length; i++) {
	          this.navItems[i].setAttribute('data-active', false);
	        }
	      },

	      addActive: function(el, name, parent){
	        if (!el){
	          el = document.querySelector('[data-nav-item="' + name + '"]');
	          parent = document.querySelector('[data-nav-item="' + parent + '"]');
	          this.active = this.stripHash(name);
	          el.setAttribute('data-active', true);
	          if (parent) {
	            parent.setAttribute('data-active', true);
	          }

	        } else {
	          this.active = this.stripHash(el.getAttribute('data-nav-item'));
	          el.setAttribute('data-active', true);
	          if (parent) {
	            parent.setAttribute('data-active', true);
	          }
	        }
	      },

	      update: function(el, name, parent){
	        this.removeActive();
	        this.addActive(el, name, parent);
	      },

	      updateSelectField: function(newValue) {
	        if (newValue){
	          this.navSelect.val(newValue);
	        }
	      },

	      registerEventHandlers: function(){
	        var self = this;
	        if (!this.navIsSelect) {
	          for (var i = 0; i < this.navItems.length; i++) {

	            var item = this.navItems[i];

	            if (!document.getElementById(item.dataset.navItem) && item) {
	              item.setAttribute('aria-hidden', true);
	            }

	            item.addEventListener('click', function () {
	              self.update(this);
	            });
	          }
	        }

	        window.addEventListener('scroll', function() {
	          self.updateScrollTop();
	          // TODO: throttle
	          self.detectNavChange();
	        });

	        window.addEventListener('resize', function(){
	          // TODO: throttle
	          self.detectNavChange();
	        });

	      },

	      changeHandler: function(selector) {
	        window.location.hash = selector.value;
	      },

	      detectNavChange: function(){

	        var self = this;

	        var items = this.navIsSelect
	          ? this.navSelect
	          : this.navItems;

	        Array.prototype.forEach.call(items, function(item){
	          var parentName,
	            newName,
	            header,
	            isActiveElement;

	          if (!self.navIsSelect) {
	            header = document.getElementById(item.dataset.navItem);

	            isActiveElement = self.isActiveElement(header);

	            if (isActiveElement) {
	              newName = header.id;

	              if (item.classList.contains(self.subnavItemClass)) {
	                parentName = item.parentElement.previousElementSibling
	                .getAttribute('data-nav-item');
	              }

	              self.update(null, newName, parentName);

	            }
	          } else if (self.navIsSelect) {
	            Array.prototype.forEach.call(item, function(option){

	              header = document.getElementById(option.value);
	              isActiveElement = self.isActiveElement(header);

	              if (isActiveElement && self.navIsSelect) {
	                newName = option.value;
	                self.updateSelectField(newName);
	              }
	            });
	          }

	        });

	        this.resetTop();
	      }
	    };

	    module.exports = exports.OpenListNav;
	  })(this);


/***/ }

/******/ });