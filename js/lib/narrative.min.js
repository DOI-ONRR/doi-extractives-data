/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	(function(exports) {
	  'use strict';

	  __webpack_require__(1);
	  var OpenListNav = __webpack_require__(23);

	  // exporting instance of OpenListNav because openListNav is
	  // referenced in the markup:
	  // _includes/hash_selecor.html
	  exports.openListNav = new OpenListNav();

	})(window);


/***/ },

/***/ 1:
/***/ function(module, exports) {

	(function(exports) {

	  var scrollLeft,
	    scrollTop;

	  var findScrollPositions = function(){
	    scrollLeft = (window.pageXOffset !== undefined)
	      ? window.pageXOffset
	      : (document.documentElement
	        || document.body.parentNode
	        || document.body).scrollLeft;
	    scrollTop = (window.pageYOffset !== undefined)
	      ? window.pageYOffset
	      : (document.documentElement
	        || document.body.parentNode
	        || document.body).scrollTop;

	  };

	  var StickyNav = function() {

	    this.elems = {
	      sticky : document.querySelector('.sticky_nav'),
	      main: document.querySelector('main')
	    };

	    this.attrStickyOffset = this.elems.sticky.getAttribute('data-sticky-offset');
	    this.attrOffsetBottom = parseInt(this.elems.sticky.getAttribute('data-offset-bottom')) || 0;
	    this.maxWidth = this.elems.sticky.getAttribute('data-max-width');
	    var attrAbsolute = this.elems.sticky.getAttribute('data-absolute');

	    this.attrParent = this.elems.sticky.getAttribute('data-offset-parent');

	    this.elems.parent = this.elems.sticky.getAttribute('data-offset-parent')
	      ? this.elems.sticky.parentNode
	      : null;

	    this.determineScreen = function() {
	      var windowWidth = window.innerWidth || document.body.clientWidth;
	      this.wasMobile = this.isMobile;
	      this.isMobile = windowWidth < 768;
	    };

	    this.determineScreen();

	    this.isAbsolute = function() {

	      var isAbsolute = (attrAbsolute === 'true' && !this.isMobile)
	        ? true
	        : false;
	      return isAbsolute;
	    }




	    this.status;
	    this.lastStatus;
	    this.lastWidth;
	    this.lastWindowWidth;
	  };

	  StickyNav.prototype = {
	    setOffset: function () {
	      this.offset = this.attrStickyOffset
	        ? parseInt(this.attrStickyOffset)
	        : !this.elems.parent
	          ? this.elems.sticky.offsetTop
	          : ( this.attrParent === 'mobile' && this.isMobile )
	            ? this.elems.parent.offsetTop - this.elems.sticky.offsetHeight
	            : this.elems.sticky.offsetTop
	    },
	    getPositions: function () {

	      this.height = this.elems.sticky.clientHeight;

	      this.lastWidth = this.width || 'initial';
	      var windowWidth = window.innerWidth || document.body.clientWidth,
	        windowBump = windowWidth > 1044 || this.isMobile ? 0 : -20;
	      this.width = this.elems.parent
	        ? this.elems.parent.clientWidth + windowBump + 'px'
	        : this.maxWidth;

	      this.mainOffset = this.elems.main.offsetTop;
	      this.mainHeight = this.elems.main.clientHeight;

	      this.diffTop = scrollTop - this.mainOffset - this.offset;

	      this.diffBottom = scrollTop + this.height - this.mainHeight - this.mainOffset;
	      this.lastStatus = this.status;
	      if (this.diffTop >= 0){
	        this.status = 'fixed';
	        if (this.diffBottom >= 0){
	          this.status = 'absolute';
	        }
	      } else {
	        this.status = 'static';
	      }
	    },
	    needsUpdate: function(init) {
	      var statusChange = this.status !== this.lastStatus;
	      var sizeChange = this.width !== this.lastWidth;
	      var updateNeeded = undefined;
	      if (!statusChange && sizeChange) {
	        updateNeeded = 'size';
	      } else if (statusChange && !sizeChange) {
	        updateNeeded = 'status';
	      } else if (statusChange && sizeChange || init === 'init') {
	        updateNeeded = 'both';
	      }
	      return updateNeeded;
	    },
	    update: function(updateNeeded) {
	      if (!updateNeeded) {
	        return;
	      } else {
	        if (this.diffTop >= 0){
	          if (updateNeeded === 'status' || updateNeeded === 'both') {
	            this.elems.sticky.style.position = 'fixed';
	            this.elems.sticky.style.top = 0;
	            this.elems.sticky.classList.remove('js-transparent');
	            this.elems.sticky.classList.add('js-color');
	          }

	          if (updateNeeded === 'size' || updateNeeded === 'both') {
	            this.elems.sticky.style.width = this.width;
	          }

	          if (this.diffBottom >= 0){
	            if (updateNeeded === 'status' || updateNeeded === 'both') {
	              this.elems.sticky.style.position = 'absolute';

	              if ( this.attrParent === 'mobile' && this.isMobile ) {
	                this.elems.sticky.style.top = this.mainHeight - this.offset - this.height - this.attrOffsetBottom + 'px';
	              } else {
	                this.elems.sticky.style.top = this.mainHeight - this.height - this.attrOffsetBottom + 'px';
	              }
	            }
	          }
	        } else {
	          if (updateNeeded === 'status' || updateNeeded === 'both') {
	            this.elems.sticky.classList.remove('js-color');
	            this.elems.sticky.classList.add('js-transparent');
	            if (this.isAbsolute()) {
	              this.elems.sticky.style.position = 'absolute';
	            } else {
	              this.elems.sticky.style.position = 'static';
	            }
	          }

	          if (updateNeeded === 'size' || updateNeeded === 'both') {
	            this.elems.sticky.style.width = this.width;
	          }
	        }
	      }
	    },
	    throttle : function (fn, threshhold, scope) {
	      threshhold || (threshhold = 250);
	      var last,
	          deferTimer;
	      return function () {
	        var context = scope || this;

	        var now = +new Date,
	            args = arguments;
	        if (last && now < last + threshhold) {
	          // hold on to it
	          clearTimeout(deferTimer);
	          deferTimer = setTimeout(function () {
	            last = now;
	            fn.apply(context, args);
	          }, threshhold);
	        } else {
	          last = now;
	          fn.apply(context, args);
	        }
	      };
	    },
	    run: function(init) {
	      findScrollPositions();
	      if (init === 'init') {
	        this.setOffset();
	      }
	      this.getPositions();
	      this.update(this.needsUpdate(init));
	    }
	  };

	  var stickyNav = new StickyNav();

	  var loadDelay = stickyNav.elems.sticky.getAttribute('data-load-delay');
	  if (loadDelay) {
	    setTimeout(function() {
	      stickyNav.run('init');
	    }, parseInt(loadDelay));
	  } else {
	    stickyNav.run('init');
	  }



	  window.addEventListener('scroll', stickyNav.throttle(stickyNav.run, 130, stickyNav));

	  window.addEventListener('resize', stickyNav.throttle(stickyNav.run, 150, stickyNav));

	  // documentation: https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver
	  var observer = new MutationObserver(function () {
	    stickyNav.run();
	  });

	  // set up your configuration
	  // this will watch to see if you insert or remove any children
	  var config = { subtree: true, childList: true };

	  // start observing
	  observer.observe(stickyNav.elems.sticky, config);

	  // other potential elem listener
	  // http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/

	  exports.stickyNav = stickyNav;


	})(this);


/***/ },

/***/ 23:
/***/ function(module, exports) {

	(function(exports) {
	    function getScrollTop() {
	      return (window.pageYOffset !== undefined)
	        ? window.pageYOffset
	        : (document.documentElement
	          || document.body.parentNode
	          || document.body).scrollTop;
	    }



	    exports.OpenListNav = function() {
	      // init OpenListNav Properties
	      this.active = this.stripHash(window.location.hash) || 'intro';
	      this.navItems = document.querySelectorAll('[data-nav-item]');
	      this.navSelect = $('[data-nav-options]');
	      this.navIsSelect = !!this.navSelect.length;
	      // initialize at maximum value
	      this.defaultTop = 1e8;
	      this.closestToTop = this.defaultTop;
	      this.viewportElements = 0;
	      this.subnavItemClass = 'sticky_nav-nav_item-sub';
	      this.scrollTop = {
	        current: getScrollTop(),
	        prev: getScrollTop(),
	        direction: 'down'
	      };

	      this.registerEventHandlers();
	    };

	    exports.OpenListNav.prototype = {
	      updateScrollTop: function() {
	        this.scrollTop.prev = this.scrollTop.current;
	        this.scrollTop.current = getScrollTop();
	        this.scrollTop.direction = (this.scrollTop.current >= this.scrollTop.prev)
	          ? 'down'
	          : 'up';
	      },

	      isActiveElement: function(el) {
	        if (!el) {
	          return;
	        }

	        var status = false;
	        var rect = el.getBoundingClientRect();

	        var elementInViewport = rect.bottom > 0 &&
	            rect.right > 0 &&
	            rect.left < (window.innerWidth ||
	                         document.documentElement.clientWidth) &&
	            rect.top < (window.innerHeight ||
	                        document.documentElement.clientHeight);

	        var elTop = Math.abs(rect.top);

	        if (elementInViewport && (elTop < this.closestToTop) ) {
	          this.closestToTop = elTop;
	          this.viewportElements++;
	          status = true;
	        } else if (elementInViewport &&
	                  (this.viewportElements < 1) &&
	                  (elTop >= this.closestToTop) ) {
	          this.viewportElements++;
	          status = true;
	        }

	        return status;
	      },

	      stripHash: function (str) {
	        return str.charAt(0) === '#'
	          ? str.slice(1, str.length)
	          : str;
	      },

	      resetTop: function(){
	        this.closestToTop = this.defaultTop;
	        this.viewportElements = 0;
	      },

	      removeActive: function(){
	        this.active = null;
	        for (var i = 0; i < this.navItems.length; i++) {
	          this.navItems[i].setAttribute('data-active', false);
	        }
	      },

	      addActive: function(el, name, parent){
	        if (!el){
	          el = document.querySelector('[data-nav-item="' + name + '"]');
	          parent = document.querySelector('[data-nav-item="' + parent + '"]');
	          this.active = this.stripHash(name);
	          el.setAttribute('data-active', true);
	          if (parent) {
	            parent.setAttribute('data-active', true);
	          }

	        } else {
	          this.active = this.stripHash(el.getAttribute('data-nav-item'));
	          el.setAttribute('data-active', true);
	          if (parent) {
	            parent.setAttribute('data-active', true);
	          }
	        }
	      },

	      update: function(el, name, parent){
	        this.removeActive();
	        this.addActive(el, name, parent);
	      },

	      updateSelectField: function(newValue) {
	        if (newValue){
	          this.navSelect.val(newValue);
	        }
	      },

	      registerEventHandlers: function(){
	        var self = this;
	        if (!this.navIsSelect) {
	          for (var i = 0; i < this.navItems.length; i++) {
	            var item = this.navItems[i];
	            item.addEventListener('click', function () {
	              self.update(this);
	            });
	          }
	        }

	        window.addEventListener('scroll', function() {
	          self.updateScrollTop();
	          // TODO: throttle
	          self.detectNavChange();
	        });

	        window.addEventListener('resize', function(){
	          // TODO: throttle
	          self.detectNavChange();
	        });

	      },

	      changeHandler: function(selector) {
	        window.location.hash = selector.value;
	      },

	      detectNavChange: function(){

	        var self = this;

	        var items = this.navIsSelect
	          ? this.navSelect
	          : this.navItems;

	        Array.prototype.forEach.call(items, function(item){
	          var parentName,
	            newName,
	            header,
	            isActiveElement;

	          if (!self.navIsSelect) {
	            header = document.getElementById(item.dataset.navItem);

	            isActiveElement = self.isActiveElement(header);

	            if (isActiveElement) {
	              newName = header.id;

	              if (item.classList.contains(self.subnavItemClass)) {
	                parentName = item.parentElement.previousElementSibling
	                .getAttribute('data-nav-item');
	              }

	              self.update(null, newName, parentName);

	            }
	          } else if (self.navIsSelect) {
	            Array.prototype.forEach.call(item, function(option){

	              header = document.getElementById(option.value);
	              isActiveElement = self.isActiveElement(header);

	              if (isActiveElement && self.navIsSelect) {
	                newName = option.value;
	                self.updateSelectField(newName);
	              }
	            });
	          }

	        });

	        this.resetTop();
	      }
	    };

	    module.exports = exports.OpenListNav;
	  })(this);


/***/ }

/******/ });